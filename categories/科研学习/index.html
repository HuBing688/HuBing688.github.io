<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>科研学习 | ExampleSite</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Me"><link rel=canonical href=https://examplesite.com/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://examplesite.com/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/index.xml title=rss><link rel=alternate hreflang=en href=https://examplesite.com/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://examplesite.com/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="科研学习"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="科研学习"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://examplesite.com/ accesskey=h title="Home (Alt + H)"><img src=https://examplesite.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://examplesite.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://examplesite.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://examplesite.com/>Home</a>&nbsp;»&nbsp;<a href=https://examplesite.com/categories/>Categories</a></div><h1>科研学习
<a href=/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Practical Techniques for Searches on Encrypted Data</h2></header><div class=entry-content><p>论文信息 发表: IEEE Symposium on Security and Privacy (CCF A, 2000) 阅读目的: 了解它是怎么在密文中搜索的, 找网络数据包传输过程中如何检测被修改的idea. 作者使用的思想为A XOR B XOR B = A, 但本文是第一篇提出在在密文中搜索. 略过所有数学证明和背景介绍. 应用场景 Alice 要存储文档到Bob的服务器中, 此时只能存储密文, 因为Alice 并不放心Bob. 但这时, Alice 想要返回所有包含词’W’的文档, 这时就需要Bob在加密的文档中搜索.
方案1: 基础方案 假设想要加密的文档有\(W_1, W_2, …, W_l\)个单词.
加密: Alice 要想加密, 就先使用伪随机数生成器G生成一个随机数序列\(S_1, …, S_l\). 每个\(S_i\) 有 n-m bit 的长度. 要对每i个位置的单词\(W_i\) 加密, Alice首先生成一个\(T_i = &lt;S_i, F_{k_i}(S_i)>\)(\(&lt;\cdot, \cdot>\)表示比特连接), 并获得该单词的加密结果: \(C_i := W_i \oplus T_i\). 因为只有Alice 能生成 \(T_1, …, T_l\), 所以这个方法是相对安全的.
查找: 想要搜索单词W, Alice需要将W, 以个W可能出现位置对应的\(k_i\)发送给Bob. Bob通过检查\(C_i \oplus W_i\) 是否等于一些\(&lt;s, F_{k_i}(s)>\)来进行对加密文档的搜索.
...</p></div><footer class=entry-footer><span title='2023-07-22 21:13:00 +0800 +0800'>July 22, 2023</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>164 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Practical Techniques for Searches on Encrypted Data" href=https://examplesite.com/posts/org_26_se/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>IEEE论文的引用怎么弄?</h2></header><div class=entry-content><p>参考 这里 参考自这里
期刊(人,题,期,卷,(号),月,年,页) bib文件的通用格式如下.
这里的作者要用全名, 如果要用 et al. 的话, 是在.bst配置文件里设置的
月是使用三个字母的缩写的；
发现这里其实是没有number的, 因为不是所有的期刊都提供了number, 所以这是一个可选项；
月的缩写如下:
必需的域如下(黑体字):
当文章是pending publication状态时, 可以使用note:
这时年份也可改:
会议(人,题,期,地,月,年,页) bib文件的通用格式如下:
会议名字前面通常会添加 Proc. (这并不是动配置的,因为有些会议不适用)； 必需的域如下:
当要在月里面加上日时,可以这么做:
书 (人,题,出版商,地,年) bib文件的通用格式如下:
必需的域如下:
版本号每一个字母大写:
其实我还想找url, 但是没找到</p></div><footer class=entry-footer><span title='2023-07-06 15:11:00 +0800 +0800'>July 6, 2023</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>35 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to IEEE论文的引用怎么弄?" href=https://examplesite.com/posts/org_25_cite_in_ieee/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>On a Multi-criteria Clustering Approachfor Attack Attribution</h2></header><div class=entry-content><p>论文信息 SigKDD, 2010
阅读目的: 了解攻击溯源相关知识, 主要是为了扩充知识面.
结论: 这个文章中提供的是一个数据挖掘的方法, 针对已有的数据样本通过找它们的相似性簇并通过分析来获得结论, 所以这个文章并不是我想要的. 以下总结阅读时做的一些笔记.
论文基本信息 多准则聚类方法来解决数据挖掘中的攻击溯源问题。使用网络蜜罐数据集和本方法相结合可找到攻击源的IP。方法分为三个步骤:
特征选择：选择要分析的特征 为每个选择的特征构建无向带权图 聚合：对图进行聚合，通过学习为造成现象的行为进行建模 特征选择 这里是人工分析选择的,没有什么特别的技术
基于图的聚类 每个特征假设为p维的向量, 一个有n个样本, 这样对所有的样本,每个特征都可以生成一个矩阵。有n个特征，即有n个这种矩阵, 即如下:
对于某个特征有N个样本, 这些样本的特征值作为一个节点, 不同节点之间的距离作为边从而构建无向带权图. 即对于第k个特征的节点集为: \(V_k = \{x_1^k, X_2^k, …, X_N^k\}\). 这个特征所生成的图记为\(G_k\).
然后在这个图上找到最大的全连通子图，在一个实际的例子中这代表在某一个特征上这些样本有相同的模式。作者采用的是寻找Dominant Sets的方法来实现该目的。
多标准聚集 不同的图进行聚焦, 感觉用处不大.
在一个蜜罐数据集上的应用 通过上面的方法选择特征,构造图,然后聚类最后获得一个一个簇, 如下图:
然后就是作者对这个图的分析了, 因为特征是自己选择的, 所以每个簇是哪个特征的聚焦也是事先知道的.</p></div><footer class=entry-footer><span title='2023-02-22 14:27:00 +0800 +0800'>February 22, 2023</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>45 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to On a Multi-criteria Clustering Approachfor Attack Attribution" href=https://examplesite.com/posts/org_21_multi_clustering/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>StackPi: New packet marking and filtering mechanisms for DDoS and IP spoofing defense</h2></header><div class=entry-content><p>论文信息 发在JSAC上, 作者: 把与我相关的部分做总结
摘要 本文提出StackPi, 一种新的数据包标记方案以及一种过滤机制。标记方案由两部分组成：基于栈的标记以及write-ahead标记。过虑机制中我们推导出一个用Pi标记进行过滤的最佳阈值策略。还提出PiIP过度器可用于检测网络协议欺骗攻击。
贡献部分内容与摘要内容基本相同.
Pi概要 Pi标记方案 Pi标记方案: 数据包在其路径上传输过程中的Pi标记如何生成。
具体过程: 每个交换机在传输包时在包的IP标识位添加标记，IP标识位通常根据全局的n分成[16/n]节，每个交换机根据数据包当前的TTL值在其相应的节下标添加它的标记，如n=2，则在路径上的最后8跳是进行标记.
原始的Pi已经很好了，但当有legacy 交换机存在时（我也不知道这是个什么交换机），性能会极大地下降，因此本文提出栈标记以及write-ahead improvement.
Pi过滤方案 Pi过滤即是定义一个被DDoS攻击的服务如何根据标记来接受包，如：当确定某个Pi标记是攻击，有该标记的所有包都丢弃，但这么做会有标记饱和问题：即Pi标记的总数是常量（216)，攻击者过多时会使服务丢弃所有的数据包。
标记饱和的一个解决方法时定义阈值（这个阈值怎么算的没看懂）， 被攻击的服务只会丢弃攻击包数超过指定阈值的数据包。
StackPi: 一种新的Pi标记方案 当所有的路由器都实现Pi时上述Pi标记方法很管用，但是现实网络是增量部署的，这就使得总会有交换机没有安装Pi。
增量部署问题 当path相同时，Pi标记也是相同的，IP标识是由终端主机初始化的，因此当有某个位未被路由器标记，这个位就会被攻击者利用。在增量部署时会存在一些交换机未实现Pi功能，而它们又会对TTL递减，这就造成了标记空洞。当常量n=2时就要求路径至少有8个路由器，且都要能够标记。
Stack Marking 基于栈的标记：当路由器收到数据包时，将自身的标记push到数据包的IP标识中，这样超过的旧标记会被丢弃。
Router Write-Ahead 栈标记在路径长度有限时仍然会有问题，因此本文提出Write-Ahead标记，在此假设每个数据包知道其下一跳的IP， 交换机要做的就是：在计算标记时，使用本IP替代上一跳IP，使用下一跳地址替代本IP。
当相邻两个路由器一个是Pi-enabled，另一个是legacy路由器时，write-ahead标记可以在计算标记时带上legacy路由器。
不好的地方：当两个Pi-enabled路由器相邻，第一个路由器在计算标记时已带下了下一个交换机，因此下一个路由器的标记并不需要。因此：在收到数据包时，路由器将最近的标记与自己的标记相比较，若相同，则默认上一跳将本跳的标记已加进去了，因此跳过本路由器的push操作并只push下一跳的标记到栈中。图2为例子。</p></div><footer class=entry-footer><span title='2022-12-06 13:14:00 +0800 +0800'>December 6, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>35 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to StackPi: New packet marking and filtering mechanisms for DDoS and IP spoofing defense" href=https://examplesite.com/posts/org_18_stackpi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Efficient Forwarding Anomaly Detection in Software-Defined Networks</h2></header><div class=entry-content><p>affliation and publication
author: Qi Li, Yunpeng Liu, Zhuotao Liu, Peng Zhang, Chunhui Pang publication: TPDS abs 本篇是FADE的翻篇版, 对FADE加强了然后发了个好的,主要思想:收集网络的rule path,并找到可以通过所有这些path的最小流,并用专用rule覆盖指定的rule path中的一些rule,再生成探针包并对专用rule统计从而得到当前是否有异常. Introduction 它将大数据背景引入本文
Related Work Problem Statement Background SDN本身的不足,问题的重要性,问题的广泛性 An Inductory Example 说明什么是rule path: 包在网络中所有匹配的规则序列记为rule path 攻击类型 Traffic hijacking: 将流丢弃,重定向到错误的path中,并不会返回原来的rule path traffic interception: 流被导到错path上,但还会回到正确的path. FADE设计 Design Overview 由四个组件组成
Flow selection model: 生成网络将会图,选择能够覆盖所有rule paths的最小flow 集 决定生成的rule数 下发专用流表 统计并检测异常 Flow Selection 构建flow rules graph(利用HSA[39]) 利用算法1选择时最小流集:对每个egress rule, 反向深度找rule path的每个rule,直到ingress gule,如此找到所有的rule path. Probe Selection 对于给定的流,对它经过的rule path中选择一些rule,这些rule称为probe. rule path的第一个rule和最后一个rule一定要选择; 对于其他的rule选择,则通过一个概率计算的方式来选择. 过程略,因第链路通常长度不会超过32,最终最优选择结果如表2: ...</p></div><footer class=entry-footer><span title='2022-12-01 22:12:00 +0800 +0800'>December 1, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>237 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Efficient Forwarding Anomaly Detection in Software-Defined Networks" href=https://examplesite.com/posts/org_17_ifade/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>High-Speed Inter-domain Fault Localization</h2></header><div class=entry-content><p>> C. Basescu, Y. -H. Lin, H. Zhang and A. Perrig, “High-Speed Inter-Domain Fault Localization,” 2016 IEEE Symposium on Security and Privacy (SP), 2016, pp. 859-877, doi: 10.1109/SP.2016.56.
文章发在SP上, 但读的时候很不好受, 很难受, 因为里面的英语表达写法很不习惯, 而且读的时候还总给人一种水时长的感觉, 挑与我相关的重点读了一下, 感觉还不错.
工作背景 AS未按要求转发数据包, 而是对包延迟发送, 丢弃和修改, 本文工作就是这样的恶意AS进行检测与定位.
工作概述 Faultpints使用 确定性采样来抓捕恶意AS.每个AS都要和源建立一个秘密数据包抽样密钥\(D_{AS_i, S}\), 且规定相应的确认包种类,如DACK. 如图1中所示, 源与目的通信, AS3是恶意的. 当AS抽样包时会存储一个数据包的fingerprint到 Bloom filter中, 这个fingerprint会捕获包的presence 和包的内容. 当包被丢弃那么D则不会发确认包,所以S会为这个数据包发探针, 所有的AS都会响应这个探针, 而源会从探针数据包中获得抽样包的信息. 源会检查响应包的密钥并对某些AS进行怀疑, 并为每个AS进行怀疑打分, 错误行为的AS的怀疑打分最终会高于其他AS.
TODO 其他章节 都略去, 写得实在冗余而且难懂
...</p></div><footer class=entry-footer><span title='2022-11-28 21:24:00 +0800 +0800'>November 28, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>115 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to High-Speed Inter-domain Fault Localization" href=https://examplesite.com/posts/org_16_fault_localization/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)</h2></header><div class=entry-content><p>简单介绍 这一篇是讲PoW基础的论文,没有具体说明PoW是什么,但给出了与PoW相关的一些定义和例子, 用于理解PoW还可. 整篇文章看完还是云里雾里的, 但大概理解了PoW其实相当于一个证明, 对于给定的一个hash函数, V知道这个函数的计算结果, 而P要做的是向V证明它知道这个计算结果所对应的原象. 因为hash算逆几乎不可能, 因此若原象是n位, P随便猜的几率为1/2^n.
定义: POW即是交互性的,又是非交互性的证明协议. 在协议执行期间P和V要进行 一个私密硬币翻转的随机数, 最终由V决定是否接收. 使用C_V来标记V的私密硬币翻转, 要保证有效的证明,就要保证C_V的生成不会被P控制. 在非交互性的PoW中, 证明者模拟与验证者的通信, 并将结果发给验证者.
隐性PoW: 一种非交互性的协议, 证明者在证明时不需要验证者的主动参与.
假设没有通信延迟, 定义开始时间\(t_s\)为V初始化它的第一轮通信；完成时间\(t_c\)为协议的最后一轮通信完成, PoW的目标即为P证明它在时间\([t_s, t_c]\)中进行了确定数量的计算. 令l为安全参数, poly为任何给定的多项式变量, 本定义在假设P可以在\([-\infty, t_c]\)的时间内进行计算. 作者对PoW的hardness进行特征化, 定义1为hardness的下界, 定义2为其上界.
定义1: PoW为(w,p)-hard: P有内存m, 若p在[t_s, t_c]时间内最多进行了w步, 则V接受它的概率至多为: \(p + o(\frac{m}{poly(l)})\). 定义2: PoW为(w,p,m)-feasible: P有内存m, 若p在\([t_s, t_c]\)时间内最多进行了w步, 且P能使V接收的概率至少为p. 定义3: 完备的PoW: 对于某个w, PoW 是(w,1,w)-feasible的. 若V的计算量大大少于P,则PoW为高效的, 且这种证明有很大的advantage. 定义4: 对于完备的PoW, w为满足 (w, 1, w)-feasible的最小值, z为V要进行的最大验证数量, 则PoW的 advantage 等于 w/z. 定义5: 两个PoW独立性的定义,略 定义6: 假设PoW1为(w,p)-hard, P1, V1分别为它的证明者了验证者. 假设P1同时也是PoW2的验证者(P1=V2), 若以下为真则PoW2为PoW1的bread pudding protocol: P1(V2) 接收PoW2, P1 可在PoW1中进行w个计算步骤并使V1接收PoW1的概率至少为: \(p+1/poly(l)\) PoW例子 PIPOW: h为单向函数, V 生成长为l的随机二进制字符串x, x’为x的l-k位. V计算出y=h(x). V发送(x’, y)给P, 若要使PoW成功, P正确要计算出y的前向x.
...</p></div><footer class=entry-footer><span title='2022-11-26 21:10:00 +0800 +0800'>November 26, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>135 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)" href=https://examplesite.com/posts/org_15_pow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>EPIC: Every packet is checked in the data plane of a path-aware internet</h2></header><div class=entry-content><p>简单介绍 这是一篇最近NSDI上路径验证相关的论文.看了好几遍但还是没进脑子,因此在此总结一遍.
路径构建 终端主机如何根据AS的信息构造包的传输: 终端主机\(H_S\)首先从路径服务器中找到路径path(文中有个beacon的词,翻译为信标,估计跟路径差不多), 并将路径嵌入到数据包中,如下:
\[PACKET := (PATH || VALHD || P) \tag{1}\]
\[PATH := (TS_{path} || SRC || DEST || HI_1 || … || HI_l) \]
\[VALHD := (ts_{pkt} || S_1 || V_1 || … || S_l || V_l || V_{SD})\]
其中P表示数据包的负载, \(SRC := (A_1 : H_S), DEST:=(A_l: H_D)\). VALHD中为验证数据包所需要的一些域, \(ts_{pkt}\)为时间戳, \(S_i\) 为每一跳的验证加密码. \(V_i\) (HVF)为由源填充的加密标签,用于让中间路径验证数据包.
术语 hop field 指由跳信息 HI, 段识别 S 和跳验证域组成的三元组. 术语packet origin为h同源,路径时间戳,数据包时间戳组成的三元组:
\[PO:=(SRC, TS_{path}, ts_{pkt})\]
...</p></div><footer class=entry-footer><span title='2022-11-26 19:43:00 +0800 +0800'>November 26, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>272 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to EPIC: Every packet is checked in the data plane of a path-aware internet" href=https://examplesite.com/posts/org_14_epic/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Current Trends of Discovery Topology in SDN</h2></header><div class=entry-content><p>affliation and publication
author: publication: 本文主要 SDN 中详细调研当前拓扑发现服务的解决办法和缺点 Abstract Intro Preliminary Knowledge LLDP 协议 Link Layer Discovery Protocal,详细解释了LLDP包每个字段的作用,但我并没有看懂
Topology Discovery 拓扑发现:物理层拓扑可以帮我们了解节点分布和节点连接,逻辑拓扑可以帮我们了解设备之间的数据流
Discoery Topology in single-domain networks Network with only OpenFlow switches 支持OF的交换机有两个特性: 1. 设置了连接控制器的端口；2. 有流表将包通过packetIn发到控制器. 控制器向每个交换机发个packetOut,并把LLDP包放里面, LLDP包的目的MAC为广播地址.交换机收到LLDP包后将其转发给所有的邻居交换机.邻居交换机收到LLDP发现不地从控制器来在,就将该LLDP包通过PacketIn发给控制器,这时LLDP包的元数据中已有了一些交换机制基本信息,如交换机ID, 交换机端口号. 信息交换过程见图5, 代价:生成packetIn包数为2倍链路数,在\[6\]中有改进,缺点:只能发现相邻交换机.
Network with Traditional and Openflow Switches 控制器要发现所有OF交换机之间的连接, 直接的或间接的(两个OF交换机中间隔了传统交换机). 当前使用2层组合拓扑发现协议进行拓扑发现即LLDp包和BDDP包, BDDP包与LLDP包不同之处为
目的地地址为广播而不是多播； EtherType为0x8999. 使用方法:控制器通过向OF交换机的每个输出端口发送BDDP包并下发匹配流表,OF 交换机收到则匹配EtherType 0x8999并返回给控制器, 此时BDDP包中与LLDP包相同有着交换机的一些信息. 传统交换机则会广播最终播给OF交换机.图6为信息交换过程. 缺点:
当前无标准. 耗资源.</p></div><footer class=entry-footer><span title='2022-09-16 23:43:00 +0800 +0800'>September 16, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>60 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Current Trends of Discovery Topology in SDN" href=https://examplesite.com/posts/org_10_topo_discover/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dynamic Packet Forwarding Verification in SDN</h2></header><div class=entry-content><p>affliation and publication
author: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee
publication: IEEE Transactions on Dependable and secure computing, 2019
abs
传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少. 作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进
与我的不同点: N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取 每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢? 每个rule结束时都会有一个统计请求. 对每个流都要有一个hash表(\(P_i\)表). 抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn? 若使用流表的过期时间控制, 那就得不停地下发流表. (是我当时没看懂, 使用流表控制packetIn, 用概率参数\(\lambda\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有) 使用的工具,或许有用: CAIDA数据集 拓扑 用于模仿dropping攻击的ovs-ofctl tool 用于模仿injection攻击的TCPreply Introduction p1: 指出交付异常检测的重要性 p2: IP网的解决办法,不足及为何不可用于SDN p3: 提出一个方法, 并用其有可行性引出challenge p4: 本文的方法及贡献 Problem Statement Basic of SDN Threat Model packet hijacking attacks. 对包改路 packet delaying attacks. 延迟 packet injection attacks. 攻击者向流中加入包 packet dropping attacks. 丢流流的包 packet tempering attacks. 修改包 hybrid attacks. 丢一些包再复制或注入同等数量的包 表1 是对当前研究方法对这些问题的解决情况:
...</p></div><footer class=entry-footer><span title='2022-09-16 22:27:00 +0800 +0800'>September 16, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>398 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Dynamic Packet Forwarding Verification in SDN" href=https://examplesite.com/posts/org_09_dyna/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://examplesite.com/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://examplesite.com/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>