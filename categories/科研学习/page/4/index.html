<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>科研学习 | ExampleSite</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Me"><link rel=canonical href=https://hubing688.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://hubing688.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/index.xml title=rss><link rel=alternate hreflang=en href=https://hubing688.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hubing688.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="科研学习"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="科研学习"><meta name=twitter:description content="ExampleSite description"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://hubing688.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://hubing688.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hubing688.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://hubing688.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://hubing688.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://hubing688.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hubing688.github.io/categories/>Categories</a></div><h1>科研学习
<a href=/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs</h2></header><div class=entry-content><p>Alvarez Cid-Fuentes J , Szabo C , Falkner K . Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs[J]. IEEE Transactions on Dependable and Secure Computing, 2018:1-1.
本文提出框架，通过周期地收集系统矩阵来提取特征，并采用在线SVM法训练和对特征进行分类从而识别异常行为：deadlock,livelock,unwanted synchronization,memory leaks。
BARCA 框架 BARCA由Behavior Extractor,Behavior Identifier,Feedback Provider组成。
Behavior Extractor:定期收集Behavior Instance(BI) Behavior Identifier:将BI分类为nomal或abnomal,并使用统计模型调用Behavioral Model(BM).当分为abnomal时，Behavior Indentifier提醒Feedback Provider，由它决定是否通知管理员。 ##行为抽取(Behavior Extractor) 定期收集系统状态矩阵生成BI。假设系统状态矩阵$M={m_i|1 \le i \le n}$,定义$r_{ij}$为在时刻j读取系统矩阵i，$s_{ij}=r_{ij},r_{i(j+1)},\dots,r_{i,(j+z)}$,z为slide window size，$B_j={s_{ij}|1 \le i\le n}$。Behavior会再一次从BI中提取特征，而对异常行为的检测可转换为对这些特征偏移的检测。转换过程如下： 行为识别（Behavior Identifier） SVM 支持向量机简介
Gradient Descent 参数更新
Data Normalization(数据归一化) 对待分类的向量进行归一化 $$x_i’=\frac{1}{1+e^{\frac{x_i-u_i}{\sigma_i}}}\ for\ 1 \le i \le n,$$ u被始化为最先接收到的向量，$\sigma$初始化为$\sigma=[1,1,\cdots,1]$ 后续更新为： $$u_i’=(1-\frac{1}{t})u_i+\frac{1}{t}x_i$$ $$\sigma_i’=(1-\frac{1}{t})\sigma_i+\frac{1}{t}(x_i’-u_i’)^2$$ 这里的x是最样接收到的向量，t为目前已处理的向量个数。
...</p></div><footer class=entry-footer><span title='2019-08-27 18:32:36 +0800 +0800'>August 27, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>124 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs" href=https://hubing688.github.io/posts/13_ad_svm_tdsc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>A Deep Learning Approach to Network Intrusion Detection</h2></header><div class=entry-content><p>Shone N , Ngoc T N , Phai V D , et al. A Deep Learning Approach to Network Intrusion Detection[J]. IEEE Transactions on Emerging Topics in Computational Intelligence, 2018, 2(1):41-50.
本文提出用stacked Non-Symmetric deep Auto-encoders 方法进行特征抽取，并将提取的特征传给随机森林进行分类的一种入侵检测方法。
基本知识介绍 当前网络安全的主要挑战 网络流量的激增 更深入和更细粒度监控的需求 协议的多种多样和数据的多元化 本文提出一种深度和浅度学习结合的方法：NDAE+RF，使用的测试数据集为KDD Cup'99和NSL-KDD。
Auto-Encoder算法 原算法 该算法有两个过程：Encoder和Decoder，Encoder过程为了让高维数据在低维中表示出来，Decoder过程将低维数据重新在高维中表示出来。 即它尝试去学习： $$h_{W,b} \approx x \tag{1}$$ h是非线性假设，W和b是权重和偏置。它的学习过程就是最小化损失函数： $$L(x,d(f(x))) \tag{2}$$ 其中，L是损失函数，d是解码函数，f是编码函数
本文的Non-Symmetric Deep Auto-Envoder 多个隐藏层，且只有编码，没有解码
假设输入向量$x\in R^d$,它将一步一步匹配隐藏层$h_i \in R^{d_i}$，使用确定性函数表示如下： $$h_i=\sigma(W_ih_{i-1}+b_i);i=1,\dots,n \tag{3}$$ 这里$h_0=x,\sigma$是挤压函数，n是隐藏层数目。 NDAE没有decoder,它的输出向量类似于如下函数， $$y=\sigma(W_{n+1}h_n+b_n+1) \tag{4}$$ 模型可通过最小重构误差获得： $$E(\theta)=\sum_{i=1}^{m}(x^{(i)}-y^{(i)})^2 \tag{5}$$
...</p></div><footer class=entry-footer><span title='2019-08-26 18:32:36 +0800 +0800'>August 26, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>100 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to A Deep Learning Approach to Network Intrusion Detection" href=https://hubing688.github.io/posts/12_dl_ids/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective</h2></header><div class=entry-content><p>Garg S , Kaur K , Kumar N , et al. Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective[J]. IEEE Transactions on Multimedia, 2019, 21(3):566-578.
本文利用受限波尔兹曼机进行异常检测。
异常检测模型 controller请求流统计信息，流收集模型收集并抽取特征，基于抽取的物征，利用改进的Restricted Boltzmann Machines进行降维，将结果交给本文提出的SVM算法中进行特征和行为分类，异常检测架构进行报告并通过安全通道发送给controller,controller根据报告进行更改流表和配置。 下图是本框架的方法论：
A 降维：受限玻尔兹曼机（RBM） 设RBM有m个可见单元$v_i:[v_1,\dots,v_m]$和n个隐藏单元$h_j:h=[h_1,\dots,h_n]$。RBM的标准概率分布可表示为： $$P(h,v:\theta)=\frac{1}{Z(\theta)}exp(a^Th+b^Tv+v^TWh) \tag{1}$$ W表示权重，a,b表示偏置值，Z区分函数（也叫归一化因子）$\theta=(W,a,b)$为模型参数。 改进：随机进行Dropout,实现方法：向量$r \in {0,1}^n$p概率将其置1,将$r_j$关联到隐藏层的$h_j$,这时的联合概念分布为： $$P(r,h,v:p,\theta)=P(r;p)\mathcal{P}(h,v|r;\theta) \tag{2}$$ where. $$P(r;p)=\sum_{j=1}^{n}p^{rj}(1-p)^{1-r_j} \tag{3}$$ $$\mathcal{P}=\frac{1}{Z’(\theta,r)}exp(a^Th+b^Tv+v^TWh) \times \sum_{j=1}^{n}g(h_j,r_j) \tag{4}$$ 其中 $$f(x)=\left{ \begin{aligned} h_j=1;if\ r_j = 1\ h_j = 0;if\ r_j=0 \end{aligned} \right. \tag{5} $$
...</p></div><footer class=entry-footer><span title='2019-08-25 18:32:36 +0800 +0800'>August 25, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>200 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective" href=https://hubing688.github.io/posts/11_dl_ad/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Automatic test packet generation</h2></header><div class=entry-content><p>Zeng H , Kazemian P , Varghese G , et al. Automatic test packet generation[C]// International Conference on Emerging Networking Experiments & Technologies. IEEE, 2012.
背景分析 当前特别需要自动化的网络测试工具
概念 packets Switch Rules：defines how header space at ingress is transformed into regions of header space of egress. Rule Historyt:包被传送过程中记录自己所经历过的规则。 Topology:拓扑结构 测试包生成算法过程 step1:生成一个all-pairs reachability table
举个例子：
图6所示，如果在$P_A$处注入all-x test packets,包会通过A传递，它会将10.0/16发送到B，将10.1/16发送到C，B再将10.0/16,tcp=80发送到$P_A$,C发送10.1/16到$P_C$，在表4第一行可见。
step2:抽样，抽取测试包，使每一个rule都会被至少一个包测试到。 step3:压缩，找到一个最小的测试包集，它们的rule history可以覆盖所有的rule(经典的最小集覆盖问题，可由贪心算法求得。)
错误定位算法 基本定义 定义：R(r,pk) = 1,(包pk在规则r下成功验证) 否则 R(r,pk)=0 包在规则下验证失败有两种情况：行为错误，包头匹配错误，这里只考虑行为错误（包被错误地处理）。我们只能在边缘观察到包，所以重新定义： $R(pk)=\left{ \begin{aligned} 0 && if\ pk\ fails\ 1 && if\ pk\ succeeds \end{aligned} \right.$
...</p></div><footer class=entry-footer><span title='2019-08-24 18:32:36 +0800 +0800'>August 24, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>131 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Automatic test packet generation" href=https://hubing688.github.io/posts/10_packet_generation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>FOCES: Detecting Forwarding Anomalies in Software Defined Networks</h2></header><div class=entry-content><p>Peng Z, Xu S, Yang Z, et al. FOCES: Detecting Forwarding Anomalies in Software Defined Networks[C]// IEEE International Conference on Distributed Computing Systems. 2018.
B类。本文提供一种在SDN中进行forwarding anomaly 检测方法，（只提供检测，并未提供定位与解决办法）
基本思想 通过switch统计计数与controller推理计数相比较，判断是否有switch恶意转发包。
算法概念 假没有n个flows($f_1,f_2,\cdots,f_n$)和m个rules($r_1,r_2,\cdots,r_n$),定义流计数矩阵（FCM）$H_{m \times n}$,其中，如果流满足规则，则对应矩阵值为1
$$ H_{i,j}=\left{ \begin{aligned} 1 && if\ f_{i}\ matches\ r_i\ 0 && otherwise \end{aligned} \right. \tag{1} $$
rule计数向量$Y=(y_1,y_2,\cdots,y_m)^T$,flow计数向量$X=(x_1,x_2,\cdots,x_n)$ 由此可得FOCES: $$HX=Y \tag{2}$$ 这是FOCES的基本依据，即：从switch处统计到的流计数与流容量和controller中计算获得的流计数相等。 假设流容量矩阵是$X_0$当switch出现交付异常时，FCM变成了$H’$,这时观察到的计数矩阵变成了$Y’=H’X_0 \neq Y_0$。由于controller并不知道$H’$，所以当需要恢复$X_0$时就要利用 $$HX=Y’ \tag{3}$$ 可以解得对$X_0$的估计 $$\hat{X} = (H^TH)^{-1}H^TY’ \tag{4}$$ 从而计算$\hat{Y} = H\hat{X}$,再计算绝对值差 $$\Delta=|Y’-\hat{Y}| \tag{5}$$ 理想情况下，当绝对值差不为0时，则认为发生了交付异常。 有的情况下交付异常无法测出，如： $X_0=(3,4,5)^T$,
...</p></div><footer class=entry-footer><span title='2019-08-23 18:32:36 +0800 +0800'>August 23, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>82 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to FOCES: Detecting Forwarding Anomalies in Software Defined Networks" href=https://hubing688.github.io/posts/09_foces/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>A Novel Anomaly Detection System to Asist Network Management in SDN Enviroment</h2></header><div class=entry-content><p>Carvalho L F , Fernandes G , Rodrigues J J P C , et al. A novel anomaly detection system to assist network management in SDN environment[C]// IEEE International Conference on Communications. IEEE, 2017.
C类。本文提出一种辅助网络管理的异常检测系统，算法运行在controller，分为四个模块：
statistic collection module controller定期向switch发送收集信息请求，并以统计的形式将特征（如源/目的IP,源/目的port等）存入profile中$X={n_1,\cdots,n_i,\cdots,n_N}$，其中$n_i$表示特征i发生次数，这样便可获得熵的信息：$H(X)=-\sum_(i=1)^N(\frac{n_i}{S})log_2(\frac{n_i}{S})$,其中，$S=\sum_{i=1}^{N}n_i$
Anomaly Detection Module 本模块目的是找到异常流。首先，从profile里获得正常流信息，信息存放在$P_{n \times a}$矩阵中，n是收集信息次数，a是信息维度，因此$p_{ij}$代表了第i个时间段的第j个特征。如果一个事件偏离profile太远，即被定义为异常，如果异常库没有该异常相关信息而将其存储并之后再检测。（这里并没有讲它是怎么计算偏移的，应该是通过熵）.有的常规流量也会有异常特征，这通过添加白名单来解决。
Mitigation Module 检测到异常就将异常流信息发送至缓解模块，缓解模块将信息插入流表以禁止恶意流量交付。
Reporting Module 向管理员提供一些有用的信息，如未知异常。
本篇感觉总体感觉价值不大。</p></div><footer class=entry-footer><span title='2019-08-22 18:32:36 +0800 +0800'>August 22, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>52 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to A Novel Anomaly Detection System to Asist Network Management in SDN Enviroment" href=https://hubing688.github.io/posts/08_ad_sdn/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>A detection method for anomaly flow in software defined network</h2></header><div class=entry-content><p>Huijun P , Zhe S , Xuejian Z , et al. [J]. IEEE Access, 2018:1-1.
本文件基于knn的一个改进算法提出了一个异常检测算法。
一些概念： 欧几里德距离：$D_{ij}^y = \sqrt{\sum_{a=1}^{t}({X_{ia} - X_{ja}})^2}$ strangeness(陌生度)：$\alpha_{iy}=\frac{\sum_{j=1}^kD_{ij}^y}{\sum_{j=1}^kD_{ij}^{-y}}$ i与正例和反例的距离之比，越小越倾向与正例。 independence(独立度)：$\theta_{iy}=\sum_{j=1}^kD_{ij}^y $ i在正例中的距离之和，越小越倾向正例。 double p value:$p_1(\alpha_i)=\frac{\#{j=(1,\cdots,n):\alpha_j \ge \alpha_i}}{n+1} $ 越大，则越正常 $p_2(\theta_i) = \frac{\#{j=(1,\cdots,n):\theta_j \ge\theta_i}}{n+1} $ 越大，则越正常 算法步骤 step1 在训练集样例中进行欧几里德距离计算 step2 在训练集样例中进行陌生度和独立度计算 step3 计算检测点的陌生度和独立度 step4 计算检测点的double p value step5 识别异常点：结点为正常用结点条件为 $p_1(\alpha_i) \ge \tau_1 \quad and \quad p_2(\theta_i) \ge \tau_2$,$\tau$由controller控制。</p></div><footer class=entry-footer><span title='2019-08-21 18:32:36 +0800 +0800'>August 21, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>62 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to A detection method for anomaly flow in software defined network" href=https://hubing688.github.io/posts/06_ad_sdn_acess/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>An Analysis of Using Reflectors for Distributed Denial-of-Service Attacks</h2></header><div class=entry-content><p>Paxson, Vern. An analysis of using reflectors for distributed denial-of-service attacks[J]. ACM SIGCOMM Computer Communication Review, 2001, 31(3):38.
本文先讲解了DDoS攻击，再讲解基于reflector的DDoS攻击，最后基于各种网络协议的字段进行挨个分析，讲解哪些字段容易受到attacker的利用从而进行攻击。
DDoS攻击结构： 使用反射器的DDoS攻击 各协议可能被攻击的字段分析
ip ：Type of Service
TCP:If the reflector’s stack has guessable TCP sequence numbers
ICMP: reflectors generating ICMP messages can likely be filtered out.
UDP:port number can be filtered.
DNS:递归查询，欺骗查询
http: would be a significant threat were it not for the likely quick traceback due to the non-spoofed connection from the slave to the proxy. Definitely a significant threat if servers running on stacks with predictable sequence numbers are widely deployed.
...</p></div><footer class=entry-footer><span title='2019-08-20 18:32:36 +0800 +0800'>August 20, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>136 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to An Analysis of Using Reflectors for Distributed Denial-of-Service Attacks" href=https://hubing688.github.io/posts/07_reflector_sigcomm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JESS: Joint Entropy-Based DDoS Defense Scheme in SDN</h2></header><div class=entry-content><p>Kalkan K , Altay L , Gur G , et al. JESS: Joint Entropy Based DDoS Defense Scheme in SDN[J]. IEEE Journal on Selected Areas in Communications, 2018:1-1.
该文提出了一种基于熵的DDoS攻击的检测与缓解办法。
introduction SDN存在安全问题，如DDoS攻击，解决办法有:
内在：structural attributes of SDN enviroment on the properties of traffic flows 外在：statistical and ml Entropy shows randomness,DDoS decraese randomness. related work 网络虚拟化及其安全 SDN安全相关研究 Join Entropy Based DDoS Defense Scheme In SDN(JESS) 分为三个小步：
nominal stage:switch sends headers of all packets to controller,controller calculates joint entropies of each pair preparatory stage:controller generate current pair profiles and calculates joint entropies,difference exceeds $\theta_j$,DDoS attack is detected,maximum difference is SuspiciousPair and send to switch active mitigation stage:switch creates SC of SuspiciousPair and send to controller,controller calculates correspoinding score and generates scoretable ST,rule table $RT_C$ with a designated $\theta_s$,if score of entry under $\theta_s$ forward, otherwise drop. 剩下的是算法的细则，太多了建议看原文
...</p></div><footer class=entry-footer><span title='2019-08-19 18:32:36 +0800 +0800'>August 19, 2019</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>283 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to JESS: Joint Entropy-Based DDoS Defense Scheme in SDN" href=https://hubing688.github.io/posts/04_jess/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks</h2></header><div class=entry-content><p>Giotis K , Androulidakis G , Maglaris V . Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks[C]// Third European Workshop on Software Defined Networks. IEEE Computer Society, 2014.
本文主要提出一种架构：利用SDN中的Controller改进现有的网络体系中进行Anomaly Detection(AD)
Introduction DDoS的危害，以前的解决办法（文献较老）会使受害主要的良性流和恶性流量均不通过，本文的架构可改善这种状况。
Motivation and related word 讲述相关工作，但并未提及本文与之不同之处。（估记就是找几个不好的讲了一讲）
Design Principles and Overall Architecture 本文提出的架构如图： A. Design pricinple 以流为粒度 data gathering,AD,mitigation function decoupling Dynamic triggering of the RTBH mechanism,remote and automatic configuation trigger device scalable traffic statistics collection using packet sampling techniques,achived by sFlow B. overflow Architecture 见图1 有三个功能：
...</p></div><footer class=entry-footer><span title='2019-08-18 18:32:36 +0800 +0800'>August 18, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>210 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks" href=https://hubing688.github.io/posts/03_sdn_ad/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://hubing688.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://hubing688.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://hubing688.github.io/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>