<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | ExampleSite</title><meta name=keywords content><meta name=description content="Posts - ExampleSite"><meta name=author content="Me"><link rel=canonical href=https://hubing688.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://hubing688.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://hubing688.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hubing688.github.io/posts/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hubing688.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://hubing688.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://hubing688.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hubing688.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://hubing688.github.io/posts/ title=posts><span class=active>posts</span></a></li><li><a href=https://hubing688.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://hubing688.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks</h2></header><div class=entry-content><p>Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer & Communications Security. ACM, 2013.
本文对of作两个改进：1,利用Connection Migration对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,actuating trigger改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。 整体架构见图1
系统设计 Connection Migration 利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤： 1收到SYN,分类：三次握手完成 2报告：得到控制器允许并插入规则 3转移：找目的host，并成功shake 4报告：通知控制器 5中继，源和目的host建立TCP session 可见图2
分类（classification stage） 流程见图3
收到TCP：查flow Table,在？交付 不在？是不是SYN？是：ACK 否：RST或丢弃
收到TCP ACK处理流程
收到TCP ACK，查flow table，在？交付 不在？查SYN缓存，有：report 无：RST或丢弃
Report stage 将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration 否：未说
...</p></div><footer class=entry-footer><span title='2019-08-31 18:32:36 +0800 +0800'>August 31, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>167 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks" href=https://hubing688.github.io/posts/18_avant-guard/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices</h2></header><div class=entry-content><p>Zhou H , Wu C , Yang C , et al. SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices[J]. IEEE/ACM Transactions on Networking, 2018, PP(99).
本文目标是通过一个审计器检测被挟持的SDN设备，实验结果并未与其他进行比较，因为他声称自己的正确率有100,但是并没有提供检测具体哪个设备被挟持。
背景介绍 目前的检测方法都是在假设Controller正常的情况下进行的，本文方法是在Controller和Switch均不可信的情况下进行，主要思想是利用备份控制器对当前设备进行检测，进行检测的设备称为审计器（我是这么翻译的），选自slave Controller，使用分布式控制器的场景如图1所示：每个switch被一个master controller管理和几个backup controller管理，当master失效后，会从backup里选一个当master。
本文算法 假设 攻击者所劫持的controller数和switch数不知道，且都有root权限，这里需要假设至少一个switch被劫持且至少一个与其相关的审计器未被劫持。
原则 审计器中每条记录需要收集的信息：网络更新请求request，master对该request执行结果，switch收到的更新指令，switch更新后的状态。审计器的每个记录会创建一个审计ID，审计器会计算结果（与master所做的工作相同），并与master比较，如果不一样，就发出警告，说明master被黑，异构控制器作为审计器会更加适合。具体过程为：master会mirror每个收到的update request给auditor,auditor依ID创建审计记录，并重新执行，最后将从master那收到的结果和自己的结果作比较；同时，switch mirror所有的PACKET_IN,instruction,state给它所有的auditor。每条审计记录包含的内容有：网络更新请求request,master的执行结果 $R_{M}$,审计器执行结果$R_A$,switch收到的更新指令$I_S$，相关switch的更新状态$R_S$，可见图2解（这里的request本质上是一个PACKET_IN消息，是switch收到不知如何处理的包时发送给Controller的一个消息）：
审计结果如下：
$R_M=I_S=R_S=R_A$正常 $R_M=I_S=R_S \neq R_A$ master被挟持。 $R_M=I_S \neq R_S$ switch被挟持。 $R_M \neq I_S$中间人攻击 switch没接到指令自己更新了， 审计器如果收到一个request就创建一个审计记录，如果是其他的审记消息就把他加入到相应审计ID的记录里，如图3
SDN-RDCD algorithm for controllers 本部分是对algorithm1中使用参数进行了相关解释，算法说明跟叙述相同。
Effectiveness Analysis 如果所有的审计器都被挟持或所有的master和switch都被hacker，这就测不出来，否则只要有一个审计器可用，则可以发出警告并通过日志找到原因。 证明算法有效：$P’$指有SDN-RDCD时被hijack的概率，$P$指没有SDN-RDCD时被hijack的概率，M指master被挟持，S指所有相关的switch被挟持，A指每一个auditor都被挟持。则： $$P=P(M\cup S)=P(M)+P(S)-P(M\cap S) \tag{1}$$ $$P’=P((M\cap A)\cup(M\cap S)\cup S)=P((M\cap A)\cup S)=P(M\cap A)+P(S)-P(M\cap A\cap S)\tag{2}$$
...</p></div><footer class=entry-footer><span title='2019-08-30 18:32:36 +0800 +0800'>August 30, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>140 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices" href=https://hubing688.github.io/posts/17_sdn-rdcd_ton/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment</h2></header><div class=entry-content><p>Kalkan K , Gur G , Alagoz F . SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment[C]// 2017 IEEE Symposium on Computers and Communications (ISCC). IEEE, 2017.
本文是JESS那篇对应的会议文章，记一下主要思想。
SDNScore Mechanism 本机制由switch中的profiler,actuator,comparator,scorer和controller中的PairProfiler组成，用于检测DDoS及其缓解。整个机制图解见图1.
Switch中的机制 Profiler 在无攻击期间switch会有一个统计period,作为正常阶段一个时间间隔的特征统计参考值，本文中switch中的profile存储8个特征的统计：source IP,destination IP,source port,destination port,proto-col type,packet size,TTL valueand，TCP flag.与此同时，该期间Profiler会将收到的所有包头发给controller,controller会根据收到的headers形成pairProfile，如以上8个特征，controller会存储$\left( \begin{aligned} 8\2 \end{aligned}\right)=28$个表，而每个switch而要存储8个表。Profiler会在整个阶段都要运行，如acturator阶段会用来形成当前的profile。PariProfile用来进行流量分析和被其他模块使用，profile用来进行选择最适合的属性。
Acturator:监控网络带宽，当带宽超过一个阈值时，即激活comparator和profiler，profiler形成当前的profile.当流量强度回归正常时，它便让其他模块进入备用状态，系统停在基于流的监控状态。
Comparator:当发生拥塞时，acturator激活这个模块，它通过比较nominal profile和current profile来决定可疑属性对：与nominal profile偏移地最远的那个，记为SuspiciousPair。然后向controller请求这个属性对的nominal profile（controller中是以属性对的形式存储的），然后scorer进行面向包的检察和选择性攻击。
Scorer: 本部分由三个小模块组成：计算打分，计算阈值，选择性丢弃包。、 **计算打分：**假设SuspiciousPair属性对$A=a_p,B=b_p$，而打分$S_p$计算为： $$S_p=\frac{PNP_{(A=a_p,B=b_p)}/TPNP}{PCP_{(A=a_p,B=b_p,\dots)}/TPCP} \tag{1}$$ **计算阈值：**本部分利用load shedding algorithm算法计算。阈值Th，使$CDF(Th)=\Phi$,$\Phi$是被丢弃的比例，$\phi$是需要接受的流量，$\varphi$是当前进入的流量，可通过 流量可表示成：$1-\Phi=\frac{\phi}{\varphi}$ **选择性丢弃：**如果打分超过阈值，则丢弃。 符号对应讲解：
Controller中的机制：PairProfiler 计算PairProfile会使Controller有额外负担，但只在nominal period这样，当comparator请求 某个SuspiciousPair时，再将相应的信息发给他。
...</p></div><footer class=entry-footer><span title='2019-08-29 18:32:36 +0800 +0800'>August 29, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>81 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment" href=https://hubing688.github.io/posts/16_sdnscore/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN</h2></header><div class=entry-content><p>Silva A S D . Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN[C]// Network Operations & Management Symposium. IEEE, 2016.
本文提出一个架构用于在SDN中的异常检测与缓解，架构分为两个阶段：检测异常（利用Entropy），分类流（Machine Learning）,并提供了实现的源码。源码下载，这个人的github里只有这一个代码项目….下面详细记录这篇文章。
framework 本架构由lightweighted 和 heavyweight 两部分组成
A. Framework requirements 本段讲解一个架构需要哪些特性、
检索网络信息 网络管理员可干预该框架 可灵活地对网络进行配置 Lightweight and Heavyweight Process 基本架构图如图1
Lightweight Processing Phase 使用控制平面获得当前流的一个快照（箭头1），并通过计算熵计算得到可疑流（箭头2）移交到下一步（箭头3）。
Heavyweight Processing phase 利用ML方式对流进行分类：benign,malicious,unknow，对malicious:mitigation操作，unknow:收集信息便于以后处理，最后要返回监督阶段。
Anomaly Traffic Classification 分类架构如图2所示
由两层构成：statistical layer和classification Layer 统计层由：statcitics Manager,Features Selector,Network Driver 组成，分类层由:Anomaly Monitor,Flow Classifier,Flow Manager组成。
Network Driver:获取流信息，并以流ID为标记，flow id 定义为：（srcip,dstip,srcport,dstport,protocol） Feature Selector：抽取特征：这些特征最好是可以区分流，且计算代价又小的特征 Statistics Manager:总结由Feature Selector和Network Driver收集到数据的特征，如：mean,standard deviation,coefficient of variance,minimun value,maxmum,value。 Anomaly Monitor:计算熵(根据IP或端口号，因为这些对找到DDoS攻击很有效)并找到异常流。假设计算的熵是E，平均熵中M，标准差是S，则正常流判定的根据是：[M-S，M+S] Flow Classifier:对统计到的流特征进行分类，使用K-means进行聚类分类，再使用SVM对每个类进行类别判别，这两个方法的结果可以互补。 Flow Manager:对鉴别的恶意流作进一步处理：丢弃或交给其他组件。 Framewrok Evaluation ...</p></div><footer class=entry-footer><span title='2019-08-28 18:32:36 +0800 +0800'>August 28, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>112 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN" href=https://hubing688.github.io/posts/15_atlantic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>A Deep Learning Based DDoS Detection System in Software-Defined Networking (SDN)</h2></header><div class=entry-content><p>Niyaz Q , Sun W , Javaid A Y . A Deep Learning Based DDoS Detection System in Software-Defined Networking (SDN)[J]. Security & Safety, 2016, 4(12).
没有看的价值，跟深度学习完全扯不上关系，被标题和页码骗了。。
DDoS Detection System的实现 分为三个部分：信息收集，特征提取，流量收集，结构图如下： ##信息收集方法命名为TCFI，具体算法流程如Algorithm1: 意思是：抽取所有的包头放到packets_list里，将新产生的流存入flow_list里。 被抽取的特征有如表1 ##特征提取和流量分类 特征提取设置时间间隔进行，特征提取模块从TCFI中获得统计信息，并计算特征，按流分类，TCFI的特征被提取后重设特征集。 可抽取的特征总结如下： TCP： UDP： ICMP： 对9-12,43-46,63-67计算字节数和每个流包数的中位数，对8,14,16,18,20,42,48,50,54,62,68计算熵。 算法部分就没有了，也没讲怎么分类。 #实验部分 从公网中抓正常流量，利用hping3构造异常流量，在构造的SDN中进行实验，计算：Accuracy,Precision,RecallF值，ROC 本文：主要了解了一些可用于特征提取的特征集，还有一个用于攻模拟攻击的工具：hping3</p></div><footer class=entry-footer><span title='2019-08-27 18:32:36 +0800 +0800'>August 27, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>45 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to A Deep Learning Based DDoS Detection System in Software-Defined Networking (SDN)" href=https://hubing688.github.io/posts/14_dl_ddos_sdn/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs</h2></header><div class=entry-content><p>Alvarez Cid-Fuentes J , Szabo C , Falkner K . Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs[J]. IEEE Transactions on Dependable and Secure Computing, 2018:1-1.
本文提出框架，通过周期地收集系统矩阵来提取特征，并采用在线SVM法训练和对特征进行分类从而识别异常行为：deadlock,livelock,unwanted synchronization,memory leaks。
BARCA 框架 BARCA由Behavior Extractor,Behavior Identifier,Feedback Provider组成。
Behavior Extractor:定期收集Behavior Instance(BI) Behavior Identifier:将BI分类为nomal或abnomal,并使用统计模型调用Behavioral Model(BM).当分为abnomal时，Behavior Indentifier提醒Feedback Provider，由它决定是否通知管理员。 ##行为抽取(Behavior Extractor) 定期收集系统状态矩阵生成BI。假设系统状态矩阵$M={m_i|1 \le i \le n}$,定义$r_{ij}$为在时刻j读取系统矩阵i，$s_{ij}=r_{ij},r_{i(j+1)},\dots,r_{i,(j+z)}$,z为slide window size，$B_j={s_{ij}|1 \le i\le n}$。Behavior会再一次从BI中提取特征，而对异常行为的检测可转换为对这些特征偏移的检测。转换过程如下： 行为识别（Behavior Identifier） SVM 支持向量机简介
Gradient Descent 参数更新
Data Normalization(数据归一化) 对待分类的向量进行归一化 $$x_i’=\frac{1}{1+e^{\frac{x_i-u_i}{\sigma_i}}}\ for\ 1 \le i \le n,$$ u被始化为最先接收到的向量，$\sigma$初始化为$\sigma=[1,1,\cdots,1]$ 后续更新为： $$u_i’=(1-\frac{1}{t})u_i+\frac{1}{t}x_i$$ $$\sigma_i’=(1-\frac{1}{t})\sigma_i+\frac{1}{t}(x_i’-u_i’)^2$$ 这里的x是最样接收到的向量，t为目前已处理的向量个数。
...</p></div><footer class=entry-footer><span title='2019-08-27 18:32:36 +0800 +0800'>August 27, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>124 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs" href=https://hubing688.github.io/posts/13_ad_svm_tdsc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>A Deep Learning Approach to Network Intrusion Detection</h2></header><div class=entry-content><p>Shone N , Ngoc T N , Phai V D , et al. A Deep Learning Approach to Network Intrusion Detection[J]. IEEE Transactions on Emerging Topics in Computational Intelligence, 2018, 2(1):41-50.
本文提出用stacked Non-Symmetric deep Auto-encoders 方法进行特征抽取，并将提取的特征传给随机森林进行分类的一种入侵检测方法。
基本知识介绍 当前网络安全的主要挑战 网络流量的激增 更深入和更细粒度监控的需求 协议的多种多样和数据的多元化 本文提出一种深度和浅度学习结合的方法：NDAE+RF，使用的测试数据集为KDD Cup'99和NSL-KDD。
Auto-Encoder算法 原算法 该算法有两个过程：Encoder和Decoder，Encoder过程为了让高维数据在低维中表示出来，Decoder过程将低维数据重新在高维中表示出来。 即它尝试去学习： $$h_{W,b} \approx x \tag{1}$$ h是非线性假设，W和b是权重和偏置。它的学习过程就是最小化损失函数： $$L(x,d(f(x))) \tag{2}$$ 其中，L是损失函数，d是解码函数，f是编码函数
本文的Non-Symmetric Deep Auto-Envoder 多个隐藏层，且只有编码，没有解码
假设输入向量$x\in R^d$,它将一步一步匹配隐藏层$h_i \in R^{d_i}$，使用确定性函数表示如下： $$h_i=\sigma(W_ih_{i-1}+b_i);i=1,\dots,n \tag{3}$$ 这里$h_0=x,\sigma$是挤压函数，n是隐藏层数目。 NDAE没有decoder,它的输出向量类似于如下函数， $$y=\sigma(W_{n+1}h_n+b_n+1) \tag{4}$$ 模型可通过最小重构误差获得： $$E(\theta)=\sum_{i=1}^{m}(x^{(i)}-y^{(i)})^2 \tag{5}$$
...</p></div><footer class=entry-footer><span title='2019-08-26 18:32:36 +0800 +0800'>August 26, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>100 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to A Deep Learning Approach to Network Intrusion Detection" href=https://hubing688.github.io/posts/12_dl_ids/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective</h2></header><div class=entry-content><p>Garg S , Kaur K , Kumar N , et al. Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective[J]. IEEE Transactions on Multimedia, 2019, 21(3):566-578.
本文利用受限波尔兹曼机进行异常检测。
异常检测模型 controller请求流统计信息，流收集模型收集并抽取特征，基于抽取的物征，利用改进的Restricted Boltzmann Machines进行降维，将结果交给本文提出的SVM算法中进行特征和行为分类，异常检测架构进行报告并通过安全通道发送给controller,controller根据报告进行更改流表和配置。 下图是本框架的方法论：
A 降维：受限玻尔兹曼机（RBM） 设RBM有m个可见单元$v_i:[v_1,\dots,v_m]$和n个隐藏单元$h_j:h=[h_1,\dots,h_n]$。RBM的标准概率分布可表示为： $$P(h,v:\theta)=\frac{1}{Z(\theta)}exp(a^Th+b^Tv+v^TWh) \tag{1}$$ W表示权重，a,b表示偏置值，Z区分函数（也叫归一化因子）$\theta=(W,a,b)$为模型参数。 改进：随机进行Dropout,实现方法：向量$r \in {0,1}^n$p概率将其置1,将$r_j$关联到隐藏层的$h_j$,这时的联合概念分布为： $$P(r,h,v:p,\theta)=P(r;p)\mathcal{P}(h,v|r;\theta) \tag{2}$$ where. $$P(r;p)=\sum_{j=1}^{n}p^{rj}(1-p)^{1-r_j} \tag{3}$$ $$\mathcal{P}=\frac{1}{Z’(\theta,r)}exp(a^Th+b^Tv+v^TWh) \times \sum_{j=1}^{n}g(h_j,r_j) \tag{4}$$ 其中 $$f(x)=\left{ \begin{aligned} h_j=1;if\ r_j = 1\ h_j = 0;if\ r_j=0 \end{aligned} \right. \tag{5} $$
...</p></div><footer class=entry-footer><span title='2019-08-25 18:32:36 +0800 +0800'>August 25, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>200 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective" href=https://hubing688.github.io/posts/11_dl_ad/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Automatic test packet generation</h2></header><div class=entry-content><p>Zeng H , Kazemian P , Varghese G , et al. Automatic test packet generation[C]// International Conference on Emerging Networking Experiments & Technologies. IEEE, 2012.
背景分析 当前特别需要自动化的网络测试工具
概念 packets Switch Rules：defines how header space at ingress is transformed into regions of header space of egress. Rule Historyt:包被传送过程中记录自己所经历过的规则。 Topology:拓扑结构 测试包生成算法过程 step1:生成一个all-pairs reachability table
举个例子：
图6所示，如果在$P_A$处注入all-x test packets,包会通过A传递，它会将10.0/16发送到B，将10.1/16发送到C，B再将10.0/16,tcp=80发送到$P_A$,C发送10.1/16到$P_C$，在表4第一行可见。
step2:抽样，抽取测试包，使每一个rule都会被至少一个包测试到。 step3:压缩，找到一个最小的测试包集，它们的rule history可以覆盖所有的rule(经典的最小集覆盖问题，可由贪心算法求得。)
错误定位算法 基本定义 定义：R(r,pk) = 1,(包pk在规则r下成功验证) 否则 R(r,pk)=0 包在规则下验证失败有两种情况：行为错误，包头匹配错误，这里只考虑行为错误（包被错误地处理）。我们只能在边缘观察到包，所以重新定义： $R(pk)=\left{ \begin{aligned} 0 && if\ pk\ fails\ 1 && if\ pk\ succeeds \end{aligned} \right.$
...</p></div><footer class=entry-footer><span title='2019-08-24 18:32:36 +0800 +0800'>August 24, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>131 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Automatic test packet generation" href=https://hubing688.github.io/posts/10_packet_generation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>FOCES: Detecting Forwarding Anomalies in Software Defined Networks</h2></header><div class=entry-content><p>Peng Z, Xu S, Yang Z, et al. FOCES: Detecting Forwarding Anomalies in Software Defined Networks[C]// IEEE International Conference on Distributed Computing Systems. 2018.
B类。本文提供一种在SDN中进行forwarding anomaly 检测方法，（只提供检测，并未提供定位与解决办法）
基本思想 通过switch统计计数与controller推理计数相比较，判断是否有switch恶意转发包。
算法概念 假没有n个flows($f_1,f_2,\cdots,f_n$)和m个rules($r_1,r_2,\cdots,r_n$),定义流计数矩阵（FCM）$H_{m \times n}$,其中，如果流满足规则，则对应矩阵值为1
$$ H_{i,j}=\left{ \begin{aligned} 1 && if\ f_{i}\ matches\ r_i\ 0 && otherwise \end{aligned} \right. \tag{1} $$
rule计数向量$Y=(y_1,y_2,\cdots,y_m)^T$,flow计数向量$X=(x_1,x_2,\cdots,x_n)$ 由此可得FOCES: $$HX=Y \tag{2}$$ 这是FOCES的基本依据，即：从switch处统计到的流计数与流容量和controller中计算获得的流计数相等。 假设流容量矩阵是$X_0$当switch出现交付异常时，FCM变成了$H’$,这时观察到的计数矩阵变成了$Y’=H’X_0 \neq Y_0$。由于controller并不知道$H’$，所以当需要恢复$X_0$时就要利用 $$HX=Y’ \tag{3}$$ 可以解得对$X_0$的估计 $$\hat{X} = (H^TH)^{-1}H^TY’ \tag{4}$$ 从而计算$\hat{Y} = H\hat{X}$,再计算绝对值差 $$\Delta=|Y’-\hat{Y}| \tag{5}$$ 理想情况下，当绝对值差不为0时，则认为发生了交付异常。 有的情况下交付异常无法测出，如： $X_0=(3,4,5)^T$,
...</p></div><footer class=entry-footer><span title='2019-08-23 18:32:36 +0800 +0800'>August 23, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>82 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to FOCES: Detecting Forwarding Anomalies in Software Defined Networks" href=https://hubing688.github.io/posts/09_foces/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://hubing688.github.io/posts/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://hubing688.github.io/posts/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://hubing688.github.io/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>