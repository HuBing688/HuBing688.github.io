<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | ExampleSite</title><meta name=keywords content><meta name=description content="Posts - ExampleSite"><meta name=author content="Me"><link rel=canonical href=https://hubing688.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://hubing688.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://hubing688.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hubing688.github.io/posts/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="Posts"><meta property="og:description" content="Just an example"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Just an example"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hubing688.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://hubing688.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://hubing688.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hubing688.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://hubing688.github.io/posts/ title=posts><span class=active>posts</span></a></li><li><a href=https://hubing688.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://hubing688.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>StackPi: New packet marking and filtering mechanisms for DDoS and IP spoofing defense</h2></header><div class=entry-content><p>论文信息 发在JSAC上, 作者: 把与我相关的部分做总结
摘要 本文提出StackPi, 一种新的数据包标记方案以及一种过滤机制。标记方案由两部分组成：基于栈的标记以及write-ahead标记。过虑机制中我们推导出一个用Pi标记进行过滤的最佳阈值策略。还提出PiIP过度器可用于检测网络协议欺骗攻击。
贡献部分内容与摘要内容基本相同.
Pi概要 Pi标记方案 Pi标记方案: 数据包在其路径上传输过程中的Pi标记如何生成。
具体过程: 每个交换机在传输包时在包的IP标识位添加标记，IP标识位通常根据全局的n分成[16/n]节，每个交换机根据数据包当前的TTL值在其相应的节下标添加它的标记，如n=2，则在路径上的最后8跳是进行标记.
原始的Pi已经很好了，但当有legacy 交换机存在时（我也不知道这是个什么交换机），性能会极大地下降，因此本文提出栈标记以及write-ahead improvement.
Pi过滤方案 Pi过滤即是定义一个被DDoS攻击的服务如何根据标记来接受包，如：当确定某个Pi标记是攻击，有该标记的所有包都丢弃，但这么做会有标记饱和问题：即Pi标记的总数是常量（216)，攻击者过多时会使服务丢弃所有的数据包。
标记饱和的一个解决方法时定义阈值（这个阈值怎么算的没看懂）， 被攻击的服务只会丢弃攻击包数超过指定阈值的数据包。
StackPi: 一种新的Pi标记方案 当所有的路由器都实现Pi时上述Pi标记方法很管用，但是现实网络是增量部署的，这就使得总会有交换机没有安装Pi。
增量部署问题 当path相同时，Pi标记也是相同的，IP标识是由终端主机初始化的，因此当有某个位未被路由器标记，这个位就会被攻击者利用。在增量部署时会存在一些交换机未实现Pi功能，而它们又会对TTL递减，这就造成了标记空洞。当常量n=2时就要求路径至少有8个路由器，且都要能够标记。
Stack Marking 基于栈的标记：当路由器收到数据包时，将自身的标记push到数据包的IP标识中，这样超过的旧标记会被丢弃。
Router Write-Ahead 栈标记在路径长度有限时仍然会有问题，因此本文提出Write-Ahead标记，在此假设每个数据包知道其下一跳的IP， 交换机要做的就是：在计算标记时，使用本IP替代上一跳IP，使用下一跳地址替代本IP。
当相邻两个路由器一个是Pi-enabled，另一个是legacy路由器时，write-ahead标记可以在计算标记时带上legacy路由器。
不好的地方：当两个Pi-enabled路由器相邻，第一个路由器在计算标记时已带下了下一个交换机，因此下一个路由器的标记并不需要。因此：在收到数据包时，路由器将最近的标记与自己的标记相比较，若相同，则默认上一跳将本跳的标记已加进去了，因此跳过本路由器的push操作并只push下一跳的标记到栈中。图2为例子。</p></div><footer class=entry-footer><span title='2022-12-06 13:14:00 +0800 +0800'>December 6, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>35 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to StackPi: New packet marking and filtering mechanisms for DDoS and IP spoofing defense" href=https://hubing688.github.io/posts/org_18_stackpi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Efficient Forwarding Anomaly Detection in Software-Defined Networks</h2></header><div class=entry-content><p>affliation and publication
author: Qi Li, Yunpeng Liu, Zhuotao Liu, Peng Zhang, Chunhui Pang publication: TPDS abs 本篇是FADE的翻篇版, 对FADE加强了然后发了个好的,主要思想:收集网络的rule path,并找到可以通过所有这些path的最小流,并用专用rule覆盖指定的rule path中的一些rule,再生成探针包并对专用rule统计从而得到当前是否有异常. Introduction 它将大数据背景引入本文
Related Work Problem Statement Background SDN本身的不足,问题的重要性,问题的广泛性 An Inductory Example 说明什么是rule path: 包在网络中所有匹配的规则序列记为rule path 攻击类型 Traffic hijacking: 将流丢弃,重定向到错误的path中,并不会返回原来的rule path traffic interception: 流被导到错path上,但还会回到正确的path. FADE设计 Design Overview 由四个组件组成
Flow selection model: 生成网络将会图,选择能够覆盖所有rule paths的最小flow 集 决定生成的rule数 下发专用流表 统计并检测异常 Flow Selection 构建flow rules graph(利用HSA[39]) 利用算法1选择时最小流集:对每个egress rule, 反向深度找rule path的每个rule,直到ingress gule,如此找到所有的rule path. Probe Selection 对于给定的流,对它经过的rule path中选择一些rule,这些rule称为probe. rule path的第一个rule和最后一个rule一定要选择; 对于其他的rule选择,则通过一个概率计算的方式来选择. 过程略,因第链路通常长度不会超过32,最终最优选择结果如表2: ...</p></div><footer class=entry-footer><span title='2022-12-01 22:12:00 +0800 +0800'>December 1, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>237 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Efficient Forwarding Anomaly Detection in Software-Defined Networks" href=https://hubing688.github.io/posts/org_17_ifade/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>High-Speed Inter-domain Fault Localization</h2></header><div class=entry-content><p>> C. Basescu, Y. -H. Lin, H. Zhang and A. Perrig, “High-Speed Inter-Domain Fault Localization,” 2016 IEEE Symposium on Security and Privacy (SP), 2016, pp. 859-877, doi: 10.1109/SP.2016.56.
文章发在SP上, 但读的时候很不好受, 很难受, 因为里面的英语表达写法很不习惯, 而且读的时候还总给人一种水时长的感觉, 挑与我相关的重点读了一下, 感觉还不错.
工作背景 AS未按要求转发数据包, 而是对包延迟发送, 丢弃和修改, 本文工作就是这样的恶意AS进行检测与定位.
工作概述 Faultpints使用 确定性采样来抓捕恶意AS.每个AS都要和源建立一个秘密数据包抽样密钥\(D_{AS_i, S}\), 且规定相应的确认包种类,如DACK. 如图1中所示, 源与目的通信, AS3是恶意的. 当AS抽样包时会存储一个数据包的fingerprint到 Bloom filter中, 这个fingerprint会捕获包的presence 和包的内容. 当包被丢弃那么D则不会发确认包,所以S会为这个数据包发探针, 所有的AS都会响应这个探针, 而源会从探针数据包中获得抽样包的信息. 源会检查响应包的密钥并对某些AS进行怀疑, 并为每个AS进行怀疑打分, 错误行为的AS的怀疑打分最终会高于其他AS.
TODO 其他章节 都略去, 写得实在冗余而且难懂
...</p></div><footer class=entry-footer><span title='2022-11-28 21:24:00 +0800 +0800'>November 28, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>115 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to High-Speed Inter-domain Fault Localization" href=https://hubing688.github.io/posts/org_16_fault_localization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)</h2></header><div class=entry-content><p>简单介绍 这一篇是讲PoW基础的论文,没有具体说明PoW是什么,但给出了与PoW相关的一些定义和例子, 用于理解PoW还可. 整篇文章看完还是云里雾里的, 但大概理解了PoW其实相当于一个证明, 对于给定的一个hash函数, V知道这个函数的计算结果, 而P要做的是向V证明它知道这个计算结果所对应的原象. 因为hash算逆几乎不可能, 因此若原象是n位, P随便猜的几率为1/2^n.
定义: POW即是交互性的,又是非交互性的证明协议. 在协议执行期间P和V要进行 一个私密硬币翻转的随机数, 最终由V决定是否接收. 使用C_V来标记V的私密硬币翻转, 要保证有效的证明,就要保证C_V的生成不会被P控制. 在非交互性的PoW中, 证明者模拟与验证者的通信, 并将结果发给验证者.
隐性PoW: 一种非交互性的协议, 证明者在证明时不需要验证者的主动参与.
假设没有通信延迟, 定义开始时间\(t_s\)为V初始化它的第一轮通信；完成时间\(t_c\)为协议的最后一轮通信完成, PoW的目标即为P证明它在时间\([t_s, t_c]\)中进行了确定数量的计算. 令l为安全参数, poly为任何给定的多项式变量, 本定义在假设P可以在\([-\infty, t_c]\)的时间内进行计算. 作者对PoW的hardness进行特征化, 定义1为hardness的下界, 定义2为其上界.
定义1: PoW为(w,p)-hard: P有内存m, 若p在[t_s, t_c]时间内最多进行了w步, 则V接受它的概率至多为: \(p + o(\frac{m}{poly(l)})\). 定义2: PoW为(w,p,m)-feasible: P有内存m, 若p在\([t_s, t_c]\)时间内最多进行了w步, 且P能使V接收的概率至少为p. 定义3: 完备的PoW: 对于某个w, PoW 是(w,1,w)-feasible的. 若V的计算量大大少于P,则PoW为高效的, 且这种证明有很大的advantage. 定义4: 对于完备的PoW, w为满足 (w, 1, w)-feasible的最小值, z为V要进行的最大验证数量, 则PoW的 advantage 等于 w/z. 定义5: 两个PoW独立性的定义,略 定义6: 假设PoW1为(w,p)-hard, P1, V1分别为它的证明者了验证者. 假设P1同时也是PoW2的验证者(P1=V2), 若以下为真则PoW2为PoW1的bread pudding protocol: P1(V2) 接收PoW2, P1 可在PoW1中进行w个计算步骤并使V1接收PoW1的概率至少为: \(p+1/poly(l)\) PoW例子 PIPOW: h为单向函数, V 生成长为l的随机二进制字符串x, x’为x的l-k位. V计算出y=h(x). V发送(x’, y)给P, 若要使PoW成功, P正确要计算出y的前向x.
...</p></div><footer class=entry-footer><span title='2022-11-26 21:10:00 +0800 +0800'>November 26, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>135 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)" href=https://hubing688.github.io/posts/org_15_pow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EPIC: Every packet is checked in the data plane of a path-aware internet</h2></header><div class=entry-content><p>简单介绍 这是一篇最近NSDI上路径验证相关的论文.看了好几遍但还是没进脑子,因此在此总结一遍.
路径构建 终端主机如何根据AS的信息构造包的传输: 终端主机\(H_S\)首先从路径服务器中找到路径path(文中有个beacon的词,翻译为信标,估计跟路径差不多), 并将路径嵌入到数据包中,如下:
\[PACKET := (PATH || VALHD || P) \tag{1}\]
\[PATH := (TS_{path} || SRC || DEST || HI_1 || … || HI_l) \]
\[VALHD := (ts_{pkt} || S_1 || V_1 || … || S_l || V_l || V_{SD})\]
其中P表示数据包的负载, \(SRC := (A_1 : H_S), DEST:=(A_l: H_D)\). VALHD中为验证数据包所需要的一些域, \(ts_{pkt}\)为时间戳, \(S_i\) 为每一跳的验证加密码. \(V_i\) (HVF)为由源填充的加密标签,用于让中间路径验证数据包.
术语 hop field 指由跳信息 HI, 段识别 S 和跳验证域组成的三元组. 术语packet origin为h同源,路径时间戳,数据包时间戳组成的三元组:
\[PO:=(SRC, TS_{path}, ts_{pkt})\]
...</p></div><footer class=entry-footer><span title='2022-11-26 19:43:00 +0800 +0800'>November 26, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>272 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to EPIC: Every packet is checked in the data plane of a path-aware internet" href=https://hubing688.github.io/posts/org_14_epic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>马尔可夫决策过程 (Markov decision processes,MDP)</h2></header><div class=entry-content><p>马尔可夫过程 参考自这里
性质(Markov Property) 马尔可夫性质指的是: 未来只与当前状态有关，与过去无关。可以使用以下定义:
可以从这个式子里面看到, 下一个状态为\(S_{t+1}\)的概率只于当前状态\(S_t\)有关, 而与更前的状态\(S_1, S_2, …, S_{t-1}\)都无关.
我们对当前状态和后续状态分别记为\(s, s’\), 从当前状态转移到后续状态的转移概率定义为:
对于一个马尔可夫过程如果有n个状态, 那这些状态互相转换则共有\(n^2\)种转移, 将这些转移过程记为一个转q称矩阵:
马尔可夫过程 (Markov Process) 记一个随机过程中:
S是有限数量的状态集
P是状态转移概率矩阵
它具有马尔可夫性质
转移概率不会随时间变化
则它是一个马尔可夫过程, 表示为\(&lt;S,P>\).
以下例子: 一个学生所处状态的随机过程
这里每一个球就是随机过程中的一个状态, 箭头表示状态转移, 箭头上的数字表示转移概率. 比如学生在Facebook这个状态, 那他有10%的概率会去Class 1 学习, 90%的概率会继续玩Facebook.
以下是可能的状态转移过程:
C1 - C2 - C3 - Pass - Sleep
C1 - FB - FB - C1 - C2 - Sleep
C1 - C2 - C3 - Pub - C2 - C3 - Pass - Sleep
...</p></div><footer class=entry-footer><span title='2022-10-04 21:44:00 +0800 +0800'>October 4, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>239 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 马尔可夫决策过程 (Markov decision processes,MDP)" href=https://hubing688.github.io/posts/org_13_markon_decision/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hoeffding's inequality (霍夫丁不等式讲解)</h2></header><div class=entry-content><p>霍夫丁不等式表达 下面的这个式子是我们常用的
Markov inequality 一个取值非负的随机变量\(X \ge 0\), 有不等式 \(P(X \ge \epsilon) \le \frac{1}{\epsilon} \mathbb{E}X\).
这个不等式的证明:
过程中使用了微积分和一些不等式的基础, 不了解了.
Jesen inequality 对于突函数而言的一个不等式
均值不等式 这里使用的其实是对\((a - b)^2 \ge 0\)的变换, 最终得到\((a+b)^2 \ge 2 \sqrt{ab}\).
霍夫丁不等式的证明 首先使用\(Y_i = X_i - \mathbb{E}_i\) 来替换原不等式, 得到新的需要证明的式子: 这里变换后\(Y_i\)的聚会范围变了, 我们设它的聚会范围为: \(a_i \le Y_i \le b_i\)
这里要对上面方框中的式子使用马尔可夫不等式来放缩,但由于我们并不能保证 \(\sum Y_i \ge 0\), 因此使用e的指数对原式进行变换, 结果如下:
这里由于\(Y_i\) 是独立同分布的, 因此可以做变换 \(e^{-t\epsilon} \cdot \mathbb{E}[e^{t \sum Y_i}] = e^{-t \epsilon} \cdot \prod \mathbb{E}[e^{t Y_i}]\)
根据\(Y_i\)的取值范围, 我们利用\(\alpha\)来修改\(Y_i\)的表达:
再将修改后的表达带入\(e^{tY_i}\) 得:
...</p></div><footer class=entry-footer><span title='2022-09-26 23:02:00 +0800 +0800'>September 26, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>227 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Hoeffding's inequality (霍夫丁不等式讲解)" href=https://hubing688.github.io/posts/org_12_hoeffding_ineq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OVS添加自定义action</h2></header><div class=entry-content><p>版本及环境 ovs 2.13.7
ubuntu 18.04
与前一篇ovs安装的环境一致，里面所提及的脚本本篇也会用到
看这篇需要有一定的OVS基础，基本概念必须要了解。
基本概念 这里讲的action并不是openflow action, 而是数据平面的执行action
OVS中流主要从两个部分转发：内核空间和用户空间
内核空间主要是通过缓存的流表转发流，若在缓存流表中未找到，则到用户空间的完整流表中找。
用户空间对于匹配的流会添加一份缓存到内核空间的流表中;
若用户空间的完整流表也没有匹配的，就把这个数据包的相关信息发到控制器。
一个OpenFlow flow有两部分的组成：match, action
match用于匹配到达的数据包，action是对匹配到的数据包执行相应的动作
下面这个图是流表的例子
下图为已有的一些action
为什么需要自定义action: 当然是已有的满足不了需求了！！！ 基本步骤 先在OVS社区进行讨论（挺难找的）
在ofp-action.c中添加新的action代码
添加parse/encode/decode代码，这是为了使ovs-ofctl和控制器使用新加的action
在内核datapath部分实现新加的action
在ovs-vswitchd中添加action的用户层面实现
将action翻译到datapath
流表的添加过程概述 对于下面这个流表
它的添加过程为：
控制平面（控制器，还有在mininet中的操作命令行中）
我们的流表字符串会被先编码为ofpacts 再将ofpacts编码为OpenFlow actions 将flow_mod 消息发送到ovs-vswitchd 数据平面：
将OpenFlow actions 解码为 ofpacts 把flow放到交换机的规则分类器中（这里要表达的意思其实是：把转换后的ofpacts放到流表中，当有数据包来了后就会进行流表匹配） 自定义action代码实现 一、添加 action 定义(OpenFlow) lib/ofp-actions.c中添加代码 这里添加我们自定义action的名字，这个名字是OpenFlow action的名字，它并不是OVS action的名字。OpenFlow action 需要解码才可转换为 OVS action。
enum ofp_raw_action_type { /* ... */ /* NX1.3+(47): struct nx_action_decap, ... */ NXAST_RAW_DECAP, /* OF1.0+(30): uint32_t. */ OFPAT_RAW_PVL, //这行是我们的，注释删掉 /* NX1.3+(48): void. */ NXAST_RAW_DEC_NSH_TTL, /* ... */ } 这里的注释 * OF1.0+(30): uint32_t. * 是必要的，它声明了OF消息的类型，序号以及构造OF消息所需要的参数，ovs会根据这里声明的类型在编译时会在/lib/ofp-actions.inc2这个文件里按put_OFAT_##ENUM的形式自动生成函数,这里生成的函数名为put_OFAT_PVL, 这个函数的第一个参数是 ofpbuf *, 其他的参数为注释中指定的参数(指定为void时则只有一个参数),因此未按指定格式注释会出错.
...</p></div><footer class=entry-footer><span title='2022-09-19 21:27:00 +0800 +0800'>September 19, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>181 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to OVS添加自定义action" href=https://hubing688.github.io/posts/org_11_ovs_add_action/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Current Trends of Discovery Topology in SDN</h2></header><div class=entry-content><p>affliation and publication
author: publication: 本文主要 SDN 中详细调研当前拓扑发现服务的解决办法和缺点 Abstract Intro Preliminary Knowledge LLDP 协议 Link Layer Discovery Protocal,详细解释了LLDP包每个字段的作用,但我并没有看懂
Topology Discovery 拓扑发现:物理层拓扑可以帮我们了解节点分布和节点连接,逻辑拓扑可以帮我们了解设备之间的数据流
Discoery Topology in single-domain networks Network with only OpenFlow switches 支持OF的交换机有两个特性: 1. 设置了连接控制器的端口；2. 有流表将包通过packetIn发到控制器. 控制器向每个交换机发个packetOut,并把LLDP包放里面, LLDP包的目的MAC为广播地址.交换机收到LLDP包后将其转发给所有的邻居交换机.邻居交换机收到LLDP发现不地从控制器来在,就将该LLDP包通过PacketIn发给控制器,这时LLDP包的元数据中已有了一些交换机制基本信息,如交换机ID, 交换机端口号. 信息交换过程见图5, 代价:生成packetIn包数为2倍链路数,在\[6\]中有改进,缺点:只能发现相邻交换机.
Network with Traditional and Openflow Switches 控制器要发现所有OF交换机之间的连接, 直接的或间接的(两个OF交换机中间隔了传统交换机). 当前使用2层组合拓扑发现协议进行拓扑发现即LLDp包和BDDP包, BDDP包与LLDP包不同之处为
目的地地址为广播而不是多播； EtherType为0x8999. 使用方法:控制器通过向OF交换机的每个输出端口发送BDDP包并下发匹配流表,OF 交换机收到则匹配EtherType 0x8999并返回给控制器, 此时BDDP包中与LLDP包相同有着交换机的一些信息. 传统交换机则会广播最终播给OF交换机.图6为信息交换过程. 缺点:
当前无标准. 耗资源.</p></div><footer class=entry-footer><span title='2022-09-16 23:43:00 +0800 +0800'>September 16, 2022</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>60 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Current Trends of Discovery Topology in SDN" href=https://hubing688.github.io/posts/org_10_topo_discover/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dynamic Packet Forwarding Verification in SDN</h2></header><div class=entry-content><p>affliation and publication
author: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee
publication: IEEE Transactions on Dependable and secure computing, 2019
abs
传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少. 作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进
与我的不同点: N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取 每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢? 每个rule结束时都会有一个统计请求. 对每个流都要有一个hash表(\(P_i\)表). 抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn? 若使用流表的过期时间控制, 那就得不停地下发流表. (是我当时没看懂, 使用流表控制packetIn, 用概率参数\(\lambda\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有) 使用的工具,或许有用: CAIDA数据集 拓扑 用于模仿dropping攻击的ovs-ofctl tool 用于模仿injection攻击的TCPreply Introduction p1: 指出交付异常检测的重要性 p2: IP网的解决办法,不足及为何不可用于SDN p3: 提出一个方法, 并用其有可行性引出challenge p4: 本文的方法及贡献 Problem Statement Basic of SDN Threat Model packet hijacking attacks. 对包改路 packet delaying attacks. 延迟 packet injection attacks. 攻击者向流中加入包 packet dropping attacks. 丢流流的包 packet tempering attacks. 修改包 hybrid attacks. 丢一些包再复制或注入同等数量的包 表1 是对当前研究方法对这些问题的解决情况:
...</p></div><footer class=entry-footer><span title='2022-09-16 22:27:00 +0800 +0800'>September 16, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>398 words</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Dynamic Packet Forwarding Verification in SDN" href=https://hubing688.github.io/posts/org_09_dyna/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://hubing688.github.io/posts/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://hubing688.github.io/posts/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://hubing688.github.io/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>