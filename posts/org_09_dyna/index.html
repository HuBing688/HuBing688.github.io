<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dynamic Packet Forwarding Verification in SDN | ExampleSite</title><meta name=keywords content="论文阅读"><meta name=description content="affliation and publication


author: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee


publication: IEEE Transactions on Dependable and secure computing, 2019


abs


传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少.
作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进

与我的不同点:

N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取
每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢?
每个rule结束时都会有一个统计请求.
对每个流都要有一个hash表(\(P_i\)表).
抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn?

若使用流表的过期时间控制, 那就得不停地下发流表.
(是我当时没看懂, 使用流表控制packetIn, 用概率参数\(\lambda\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有)




使用的工具,或许有用:

CAIDA数据集
拓扑
用于模仿dropping攻击的ovs-ofctl tool
用于模仿injection攻击的TCPreply



Introduction

p1: 指出交付异常检测的重要性
p2: IP网的解决办法,不足及为何不可用于SDN
p3: 提出一个方法, 并用其有可行性引出challenge
p4: 本文的方法及贡献

Problem Statement
Basic of SDN
Threat Model

packet hijacking attacks. 对包改路
packet delaying attacks. 延迟
packet injection attacks. 攻击者向流中加入包
packet dropping attacks. 丢流流的包
packet tempering attacks. 修改包
hybrid attacks. 丢一些包再复制或注入同等数量的包

表1 是对当前研究方法对这些问题的解决情况:"><meta name=author content="Me"><link rel=canonical href=https://examplesite.com/posts/org_09_dyna/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://examplesite.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://examplesite.com/posts/org_09_dyna/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://examplesite.com/posts/org_09_dyna/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="Dynamic Packet Forwarding Verification in SDN"><meta property="og:description" content="affliation and publication
author: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee
publication: IEEE Transactions on Dependable and secure computing, 2019
abs
传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少. 作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进
与我的不同点: N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取 每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢? 每个rule结束时都会有一个统计请求. 对每个流都要有一个hash表(\(P_i\)表). 抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn? 若使用流表的过期时间控制, 那就得不停地下发流表. (是我当时没看懂, 使用流表控制packetIn, 用概率参数\(\lambda\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有) 使用的工具,或许有用: CAIDA数据集 拓扑 用于模仿dropping攻击的ovs-ofctl tool 用于模仿injection攻击的TCPreply Introduction p1: 指出交付异常检测的重要性 p2: IP网的解决办法,不足及为何不可用于SDN p3: 提出一个方法, 并用其有可行性引出challenge p4: 本文的方法及贡献 Problem Statement Basic of SDN Threat Model packet hijacking attacks. 对包改路 packet delaying attacks. 延迟 packet injection attacks. 攻击者向流中加入包 packet dropping attacks. 丢流流的包 packet tempering attacks. 修改包 hybrid attacks. 丢一些包再复制或注入同等数量的包 表1 是对当前研究方法对这些问题的解决情况:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-16T22:27:00+08:00"><meta property="article:modified_time" content="2022-09-21T12:15:02+08:00"><meta property="article:tag" content="论文阅读"><meta property="og:image" content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Dynamic Packet Forwarding Verification in SDN"><meta name=twitter:description content="affliation and publication


author: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee


publication: IEEE Transactions on Dependable and secure computing, 2019


abs


传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少.
作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进

与我的不同点:

N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取
每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢?
每个rule结束时都会有一个统计请求.
对每个流都要有一个hash表(\(P_i\)表).
抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn?

若使用流表的过期时间控制, 那就得不停地下发流表.
(是我当时没看懂, 使用流表控制packetIn, 用概率参数\(\lambda\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有)




使用的工具,或许有用:

CAIDA数据集
拓扑
用于模仿dropping攻击的ovs-ofctl tool
用于模仿injection攻击的TCPreply



Introduction

p1: 指出交付异常检测的重要性
p2: IP网的解决办法,不足及为何不可用于SDN
p3: 提出一个方法, 并用其有可行性引出challenge
p4: 本文的方法及贡献

Problem Statement
Basic of SDN
Threat Model

packet hijacking attacks. 对包改路
packet delaying attacks. 延迟
packet injection attacks. 攻击者向流中加入包
packet dropping attacks. 丢流流的包
packet tempering attacks. 修改包
hybrid attacks. 丢一些包再复制或注入同等数量的包

表1 是对当前研究方法对这些问题的解决情况:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://examplesite.com/posts/"},{"@type":"ListItem","position":2,"name":"Dynamic Packet Forwarding Verification in SDN","item":"https://examplesite.com/posts/org_09_dyna/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dynamic Packet Forwarding Verification in SDN","name":"Dynamic Packet Forwarding Verification in SDN","description":"affliation and publication\nauthor: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee\npublication: IEEE Transactions on Dependable and secure computing, 2019\nabs\n传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少. 作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进\n与我的不同点: N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取 每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢? 每个rule结束时都会有一个统计请求. 对每个流都要有一个hash表(\\(P_i\\)表). 抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn? 若使用流表的过期时间控制, 那就得不停地下发流表. (是我当时没看懂, 使用流表控制packetIn, 用概率参数\\(\\lambda\\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有) 使用的工具,或许有用: CAIDA数据集 拓扑 用于模仿dropping攻击的ovs-ofctl tool 用于模仿injection攻击的TCPreply Introduction p1: 指出交付异常检测的重要性 p2: IP网的解决办法,不足及为何不可用于SDN p3: 提出一个方法, 并用其有可行性引出challenge p4: 本文的方法及贡献 Problem Statement Basic of SDN Threat Model packet hijacking attacks. 对包改路 packet delaying attacks. 延迟 packet injection attacks. 攻击者向流中加入包 packet dropping attacks. 丢流流的包 packet tempering attacks. 修改包 hybrid attacks. 丢一些包再复制或注入同等数量的包 表1 是对当前研究方法对这些问题的解决情况:\n","keywords":["论文阅读"],"articleBody":"affliation and publication\nauthor: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee\npublication: IEEE Transactions on Dependable and secure computing, 2019\nabs\n传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少. 作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进\n与我的不同点: N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取 每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢? 每个rule结束时都会有一个统计请求. 对每个流都要有一个hash表(\\(P_i\\)表). 抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn? 若使用流表的过期时间控制, 那就得不停地下发流表. (是我当时没看懂, 使用流表控制packetIn, 用概率参数\\(\\lambda\\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有) 使用的工具,或许有用: CAIDA数据集 拓扑 用于模仿dropping攻击的ovs-ofctl tool 用于模仿injection攻击的TCPreply Introduction p1: 指出交付异常检测的重要性 p2: IP网的解决办法,不足及为何不可用于SDN p3: 提出一个方法, 并用其有可行性引出challenge p4: 本文的方法及贡献 Problem Statement Basic of SDN Threat Model packet hijacking attacks. 对包改路 packet delaying attacks. 延迟 packet injection attacks. 攻击者向流中加入包 packet dropping attacks. 丢流流的包 packet tempering attacks. 修改包 hybrid attacks. 丢一些包再复制或注入同等数量的包 表1 是对当前研究方法对这些问题的解决情况:\n本段剩余内容: 分析已存在方法且无法用于SDN; 本文要解决的问题及假设.\nPacket Forwarding verification Design goals Novel Packet Forwarding Verification (\\(\\mathcal{N}\\)-PFV) 当包在进和出交换机时都生成 packetIn 包以确定交有没有修改；控制器定时检查包的统计信息以确定包是否交付异常. 因此产生了2个问题:\n如何交付包到控制器 中间节点何时报告统计信息 文中使用的标记见表2\nPFV的整体overview见图2:\nPFV 算法见算法1\n\\(N\\)-PFV作为NOS的一个模块运行在控制器中, 算法 1 中1-12行为NFV验证包的完整性.\n对每个从ingress来的包计算它的Message Authentication Code (MAC), 并将其存入一个hash表中(每个项都有超期时间) 对从egress来的包计算它的MAC, 并从hash表中将对应的删除并增加已验证包的计数\\(\\delta_i\\) 如果从egress的MAC无法与hash表中的匹配,定位这个交换机 7-9 若被匹配的包与总的hash个数之比小于\\(\\theta\\), 验证失败, 定位恶意交换机 10-19 当rule过期, 就检查数据平面这个rule对应所有流表的连续性, 以确定当前攻击. 不同: 每个rule都有一个timer; 每个rule最终都会触发一次流状态请求 图2中的例子中,从A中进入的包会触发packetIn, 从C中出去的包也会.若最后2个PacketIn包相等则通过验证,否则让B生成PacketIn, 若此时相等则证明链路B-C安全. 若控制器中有rule过期则收集ABC的流表并比较. 如图2中可见B有恶意行为因为他的统计信息比A少. 若此时控制器中没有MAC过期则 packet hyjacking, 否则 dropping. 可见PFV可以有效地定位恶意交换机.\nDiscussion Enhanced PFV: DynaPFV DynaPFV 通过随机抽取flow中的包并生成packetIn来降低检测代价。当收到packetIn包时以概率\\(\\lambda\\)确定下一个包是继续检测完整性还是下发流表. DynaPFV过程见算法2， 若收到packetIn包或所保存的hash中有过期的，则以一定的概率进行包完整性检查。若检查，下发检查流表（会触发packetIn）否则下发随机过期时间的流表（流表过期会触发行为检查）。\nDynamic Packet Verific ation 具体算法过程可见算法3.\n当从ingress中收到某个流\\(f_i\\)的PacketIn包时, 就为它计算MAC并将其存入hash表\\(\\mathcal{P}_i\\)中. 当从egress中收到时就计算MAC并从对应的hash表中移除并增加验证成功包的计数. 每次移除都降低抽样概率\\(\\lambda = \\lambda * \\alpha\\), 若有MAC过期则增加抽样概率\\(\\lambda = \\frac{\\lambda + 1}{2}\\). 若匹配包数与总包数之比小于\\(\\theta\\)则认为异常从而定位异常交换机. 此外初始值设定\\(\\lambda = 1, \\alpha = 0.99\\). 最后用图3来说明对上述过程举例.\nDynamic Behavior Verification 下发流表的过期时间是随机的,流表过期会触发行为检查,因此检查的间隔也是随机的.检查过程如算法4所示:\n对path上的交换机处理的包进行统计, 并都与ingress交换机的统计结果求比值, 中间交换机直接统计, egress交换机则为统计结果加检查的包数\\(S_i[0] + sizeof(\\mathcal{P}_i + \\sigma _i)\\). 比值大于\\(\\theta\\)但小于1则提高抽样概率\\(\\lambda\\), 否则减小\\(\\lambda\\). 最后清空\\(\\delta_i\\)和hash表, 并更新\\(\\sigma_i\\)\nAnalysis Detection Effectiveness Analysis 检测效果与\\(\\lambda\\)有关, 未检测到的包序列取决与一个过期时间, 通过离散包序列, 未检测包序列的长度有限,可记为{1,2,…,n}, 因此我们可以将未检测的包序列建模为马尔可夫链, 未检测到的包序列升序服从于{1,2,…,n}中的一个正态分布. 本节将数据包与其剩余未检测序列的包数相对应, 当一个包被随机选中检测则认为剩余未检测序列的包数为0. 记\\(X(t)\\)为:当第t个包到达时该序列剩余的包数, 因此\\(X(t)\\)是一个随机变量. 我们可发现:\n\\(X(t+1)\\)只取决于\\(X(t)\\) 若\\(X(t)\\)非0, 则\\(X(t+1)=X(t)-1\\) \\(X(t+1)\\)以\\(\\lambda\\)的概率为0, 或以\\(1-\\lambda\\)的概率服从均匀分布:{1,2,…,n} 由一, \\(\\{X(t)\\}\\)形成一个有n+1个状态{0,1,…,n}的马尔可夫链.\n记\\(p_{k}(t)\\)为\\(X(t) = k\\)的概率, 则\\(X(t+1)=0\\)的概率为\\(X(t)\\)为0且以\\(\\lambda\\)触发或\\(X(t)=1\\), 因此可得:\n\\begin{equation} p_0(t+1) = \\lambda p_0(t) + p_1(t) \\tag{1} \\end{equation}\n同理,\\(X(t+1)=k\\)时(1). \\(X(t)=0\\), 下一个阶段不检测且新的不检测序列触发的是k个, 此时概率为\\(\\frac{1-\\lambda}{n}p_{0}(t)\\)；(2). \\(X(t)=k+1\\), 此时概率为 \\(p_{k+1}(t)\\), 所以:\n\\begin{equation} p_k(t-1) = \\frac{1-\\lambda}{n}p_{0}(t) + p_{k+1}(t), 1 \\le k \u003c n. \\tag{2} \\end{equation}\n再同理, 当\\(X(t+1)=n\\), 则\\(X(t)\\)一定等于0, 因此:\n\\begin{equation} p_n(t+1) = \\frac{1-\\lambda}{n}p_0(t). \\tag{3} \\end{equation}\n此时, 第t个包被检测即\\(X(t)\\)为0, 概率为\\(p_{0}(t)\\). 因为\\(p_{0}(t)\\)无法被直接求得, 但它可被拓展:\\( p_0(t+1) = \\lambda p_0(t) + p_1(t) \\tag{1}\\), 再迭代替换\\(p_{k} (t+1-k)\\), \\(1 \\le k \\le n\\) , 就可以得到:\n\\begin{equation} p_0(t+1) =\\lambda p_0(t) + \\frac{1-\\lambda}{n} \\sum_{k=1}^np_0(t-k) \\tag{4} \\end{equation}\n这个式子是不平凡的, 但仍可得到平稳概率:\n\\begin{equation} \\lim_{t\\rightarrow \\infty} p_0(t) = \\frac{2}{(1+n)(1-\\lambda)+2} \\end{equation}\n图4展示了在不同的\\(\\lambda\\)时每个包的检测概率\n对\\(\\lambda\\)的选择 不能太大,否则有太多的PacketIn包, 也不能太小,因为每个包的检测概率\\(\\frac{2}{(1+n)(1-\\lambda)+2}\\) 不能低于0.2. 因此在本文的算法中使用动态的\\(\\lambda\\)选择法, 让其增长时不会超过1. 本文选择的初始值\\(\\lambda = 1, \\alpha = 0.99\\)\nSecurity Analysis 主要讲了每种攻击是如何被检测到的, 可看原文\nPerformance Evaluation 在mininet和真实硬件上测试,所使用的trace从CAIDA\\[2\\]上获得\nImplementation DynaPFV Mode 实现MAC及其定时功能 Kernel Model 修改Floodlight, 使数据平面可以只接收packetOut而不接收修改流表操作 Experiment Setup 实验平台 攻击的实现 丢包: 使用ovs-ofctl工具在这. 包注入: 使用TCPreply. \\(\\theta\\): 设为98.9 Mininet Experiment Results 每个主机生成250个流并每秒共生成1000个包 Experiment A1: Detection Accuracy 见图6a:不同的触发概率, 不同的攻击, 不同的篡改间隔, 不同的篡改持续时间\n图6a是检测性能对不同\\(\\lambda\\)的检测效果, 动态的效果更好.\nExperiment A.2: Selection of \\(\\tau\\): 实验结果如下:\n结果表明可以在6秒内检测出大多数攻击.\nExperiment A.3: Detection Delay: 检测不同\\(\\lambda\\)时的检测时延和流数与检测时延的关系, 结果见图8\nExperiment A.4: Overhead: 比较不同\\(\\lambda\\)时packetIn的触发概率,导致的延迟和吞吐量的变化, 比较不同path长度时包的将会延迟, 检测结果如图9. 再没通信代价, 结果见图10\nHardware Testbed Experiment Results 使用4个EdgeCore AS4610-54T交换机, 使用 CAIDE数据集. Experiment B.1: Detection Delays: 不同的包率和不同攻击的检测延迟,CDF见图11:\nExperiment B.2: Overhead: 对包传输时迟的影响和吞吐量随\\(\\lambda\\)的变化见图12:\n","wordCount":"398","inLanguage":"en","image":"https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-09-16T22:27:00+08:00","dateModified":"2022-09-21T12:15:02+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://examplesite.com/posts/org_09_dyna/"},"publisher":{"@type":"Organization","name":"ExampleSite","logo":{"@type":"ImageObject","url":"https://examplesite.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://examplesite.com/ accesskey=h title="Home (Alt + H)"><img src=https://examplesite.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://examplesite.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://examplesite.com/posts/ title=posts><span>posts</span></a></li><li><a href=https://examplesite.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://examplesite.com/>Home</a>&nbsp;»&nbsp;<a href=https://examplesite.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Dynamic Packet Forwarding Verification in SDN</h1><div class=post-meta><span title='2022-09-16 22:27:00 +0800 +0800'>September 16, 2022</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>398 words</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/org_09_Dyna.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=post-content><p><strong>affliation and publication</strong></p><ul><li><p>author: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee</p></li><li><p>publication: IEEE Transactions on Dependable and secure computing, 2019</p></li><li><p>abs</p></li></ul><p>传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少.
作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进</p><ol><li>与我的不同点:<ul><li>N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取</li><li>每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢?</li><li>每个rule结束时都会有一个统计请求.</li><li>对每个流都要有一个hash表(\(P_i\)表).</li><li>抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn?<ul><li>若使用流表的过期时间控制, 那就得不停地下发流表.</li><li>(是我当时没看懂, 使用流表控制packetIn, 用概率参数\(\lambda\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有)</li></ul></li></ul></li><li>使用的工具,或许有用:<ul><li><a href="http://www.caida.org/data/passive/trace_stats/chicago-B/2015/?monitor=2%200150219-130000.UTC">CAIDA数据集</a></li><li><a href=http://www.internet2.edu/>拓扑</a></li><li>用于模仿dropping攻击的<a href=http://openvswitch.org>ovs-ofctl tool</a></li><li>用于模仿injection攻击的<a href=http://tcpreplay.appneta.com>TCPreply</a></li></ul></li></ol><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><ul><li>p1: 指出交付异常检测的重要性</li><li>p2: IP网的解决办法,不足及为何不可用于SDN</li><li>p3: 提出一个方法, 并用其有可行性引出challenge</li><li>p4: 本文的方法及贡献</li></ul><h2 id=problem-statement>Problem Statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h2><h3 id=basic-of-sdn>Basic of SDN<a hidden class=anchor aria-hidden=true href=#basic-of-sdn>#</a></h3><h3 id=threat-model>Threat Model<a hidden class=anchor aria-hidden=true href=#threat-model>#</a></h3><ul><li><em>packet hijacking attacks.</em> 对包改路</li><li><em>packet delaying attacks.</em> 延迟</li><li><em>packet injection attacks.</em> 攻击者向流中加入包</li><li><em>packet dropping attacks.</em> 丢流流的包</li><li><em>packet tempering attacks.</em> 修改包</li><li><em>hybrid attacks.</em> 丢一些包再复制或注入同等数量的包</li></ul><p>表1 是对当前研究方法对这些问题的解决情况:</p><figure><img loading=lazy src=/ox-hugo/18868vhE.png></figure><p>本段剩余内容: 分析已存在方法且无法用于SDN; 本文要解决的问题及假设.</p><h2 id=packet-forwarding-verification>Packet Forwarding verification<a hidden class=anchor aria-hidden=true href=#packet-forwarding-verification>#</a></h2><h3 id=design-goals>Design goals<a hidden class=anchor aria-hidden=true href=#design-goals>#</a></h3><h3 id=novel-packet-forwarding-verification--mathcal-n-pfv>Novel Packet Forwarding Verification (\(\mathcal{N}\)-PFV)<a hidden class=anchor aria-hidden=true href=#novel-packet-forwarding-verification--mathcal-n-pfv>#</a></h3><p>当包在进和出交换机时都生成 packetIn 包以确定交有没有修改；控制器定时检查包的统计信息以确定包是否交付异常. 因此产生了2个问题:</p><ol><li>如何交付包到控制器</li><li>中间节点何时报告统计信息</li></ol><p>文中使用的标记见表2</p><figure><img loading=lazy src=/ox-hugo/18868jKd.png></figure><p>PFV的整体overview见图2:</p><figure><img loading=lazy src=/ox-hugo/188688rK.png></figure><p>PFV 算法见算法1</p><figure><img loading=lazy src=/ox-hugo/18868J2Q.png></figure><p>\(N\)-PFV作为NOS的一个模块运行在控制器中, 算法 1 中1-12行为NFV验证包的完整性.</p><ol><li>对每个从ingress来的包计算它的Message Authentication Code (MAC), 并将其存入一个hash表中(每个项都有超期时间)</li><li>对从egress来的包计算它的MAC, 并从hash表中将对应的删除并增加已验证包的计数\(\delta_i\)</li><li>如果从egress的MAC无法与hash表中的匹配,定位这个交换机 7-9</li><li>若被匹配的包与总的hash个数之比小于\(\theta\), 验证失败, 定位恶意交换机 10-19</li><li>当rule过期, 就检查数据平面这个rule对应所有流表的连续性, 以确定当前攻击. <strong>不同: 每个rule都有一个timer; 每个rule最终都会触发一次流状态请求</strong></li></ol><p>图2中的例子中,从A中进入的包会触发packetIn, 从C中出去的包也会.若最后2个PacketIn包相等则通过验证,否则让B生成PacketIn, 若此时相等则证明链路B-C安全.
若控制器中有rule过期则收集ABC的流表并比较. 如图2中可见B有恶意行为因为他的统计信息比A少. 若此时控制器中没有MAC过期则 <em>packet hyjacking</em>, 否则 <em>dropping</em>. 可见PFV可以有效地定位恶意交换机.</p><h3 id=discussion>Discussion<a hidden class=anchor aria-hidden=true href=#discussion>#</a></h3><h2 id=enhanced-pfv-dpfv>Enhanced PFV: DynaPFV<a hidden class=anchor aria-hidden=true href=#enhanced-pfv-dpfv>#</a></h2><p>DynaPFV 通过随机抽取flow中的包并生成packetIn来降低检测代价。当收到packetIn包时以概率\(\lambda\)确定下一个包是继续检测完整性还是下发流表.
DynaPFV过程见算法2， 若收到packetIn包或所保存的hash中有过期的，则以一定的概率进行包完整性检查。若检查，下发检查流表（会触发packetIn）否则下发随机过期时间的流表（流表过期会触发行为检查）。</p><figure><img loading=lazy src=/ox-hugo/6438sVT.png></figure><h3 id=dynamic-packet-verific>Dynamic Packet Verific<a hidden class=anchor aria-hidden=true href=#dynamic-packet-verific>#</a></h3><p>ation
具体算法过程可见算法3.</p><figure><img loading=lazy src=/ox-hugo/64385fZ.png></figure><p>当从ingress中收到某个流\(f_i\)的PacketIn包时, 就为它计算MAC并将其存入hash表\(\mathcal{P}_i\)中. 当从egress中收到时就计算MAC并从对应的hash表中移除并增加验证成功包的计数. 每次移除都降低抽样概率\(\lambda = \lambda * \alpha\), 若有MAC过期则增加抽样概率\(\lambda = \frac{\lambda + 1}{2}\). 若匹配包数与总包数之比小于\(\theta\)则认为异常从而定位异常交换机. 此外初始值设定\(\lambda = 1, \alpha = 0.99\).
最后用图3来说明对上述过程举例.</p><figure><img loading=lazy src=/ox-hugo/6438Gqf.png></figure><h3 id=dynamic-behavior-verification>Dynamic Behavior Verification<a hidden class=anchor aria-hidden=true href=#dynamic-behavior-verification>#</a></h3><p>下发流表的过期时间是随机的,流表过期会触发行为检查,因此检查的间隔也是随机的.检查过程如算法4所示:</p><figure><img loading=lazy src=/ox-hugo/6438T0l.png></figure><p>对path上的交换机处理的包进行统计, 并都与ingress交换机的统计结果求比值, 中间交换机直接统计, egress交换机则为统计结果加检查的包数\(S_i[0] + sizeof(\mathcal{P}_i + \sigma _i)\). 比值大于\(\theta\)但小于1则提高抽样概率\(\lambda\), 否则减小\(\lambda\). 最后清空\(\delta_i\)和hash表, 并更新\(\sigma_i\)</p><h2 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h2><h3 id=detection-effectiveness-analysis>Detection Effectiveness Analysis<a hidden class=anchor aria-hidden=true href=#detection-effectiveness-analysis>#</a></h3><p>检测效果与\(\lambda\)有关, 未检测到的包序列取决与一个过期时间, 通过离散包序列, 未检测包序列的长度有限,可记为{1,2,&mldr;,n}, 因此我们可以将未检测的包序列建模为马尔可夫链, 未检测到的包序列升序服从于{1,2,&mldr;,n}中的一个正态分布.
本节将数据包与其剩余未检测序列的包数相对应, 当一个包被随机选中检测则认为剩余未检测序列的包数为0. 记\(X(t)\)为:当第t个包到达时该序列剩余的包数, 因此\(X(t)\)是一个随机变量. 我们可发现:</p><ol><li>\(X(t+1)\)只取决于\(X(t)\)</li><li>若\(X(t)\)非0, 则\(X(t+1)=X(t)-1\)</li><li>\(X(t+1)\)以\(\lambda\)的概率为0, 或以\(1-\lambda\)的概率服从均匀分布:{1,2,&mldr;,n}</li></ol><p>由一, \(\{X(t)\}\)形成一个有n+1个状态{0,1,&mldr;,n}的马尔可夫链.</p><p>记\(p_{k}(t)\)为\(X(t) = k\)的概率, 则\(X(t+1)=0\)的概率为\(X(t)\)为0且以\(\lambda\)触发或\(X(t)=1\), 因此可得:</p><p>\begin{equation}
p_0(t+1) = \lambda p_0(t) + p_1(t) \tag{1}
\end{equation}</p><p>同理,\(X(t+1)=k\)时(1). \(X(t)=0\), 下一个阶段不检测且新的不检测序列触发的是k个, 此时概率为\(\frac{1-\lambda}{n}p_{0}(t)\)；(2). \(X(t)=k+1\), 此时概率为 \(p_{k+1}(t)\), 所以:</p><p>\begin{equation}
p_k(t-1) = \frac{1-\lambda}{n}p_{0}(t) + p_{k+1}(t), 1 \le k &lt; n. \tag{2}
\end{equation}</p><p>再同理, 当\(X(t+1)=n\), 则\(X(t)\)一定等于0, 因此:</p><p>\begin{equation}
p_n(t+1) = \frac{1-\lambda}{n}p_0(t). \tag{3}
\end{equation}</p><p>此时, 第t个包被检测即\(X(t)\)为0, 概率为\(p_{0}(t)\). 因为\(p_{0}(t)\)无法被直接求得, 但它可被拓展:\( p_0(t+1) = \lambda p_0(t) + p_1(t) \tag{1}\), 再迭代替换\(p_{k} (t+1-k)\), \(1 \le k \le n\) , 就可以得到:</p><p>\begin{equation}
p_0(t+1) =\lambda p_0(t) + \frac{1-\lambda}{n} \sum_{k=1}^np_0(t-k) \tag{4}
\end{equation}</p><p>这个式子是不平凡的, 但仍可得到平稳概率:</p><p>\begin{equation}
\lim_{t\rightarrow \infty} p_0(t) = \frac{2}{(1+n)(1-\lambda)+2}
\end{equation}</p><p>图4展示了在不同的\(\lambda\)时每个包的检测概率</p><figure><img loading=lazy src=/ox-hugo/6438g-r.png></figure><p>对\(\lambda\)的选择 不能太大,否则有太多的PacketIn包, 也不能太小,因为每个包的检测概率\(\frac{2}{(1+n)(1-\lambda)+2}\) 不能低于0.2. 因此在本文的算法中使用动态的\(\lambda\)选择法, 让其增长时不会超过1. 本文选择的初始值\(\lambda = 1, \alpha = 0.99\)</p><h3 id=security-analysis>Security Analysis<a hidden class=anchor aria-hidden=true href=#security-analysis>#</a></h3><p>主要讲了每种攻击是如何被检测到的, 可看原文</p><h2 id=performance-evaluation>Performance Evaluation<a hidden class=anchor aria-hidden=true href=#performance-evaluation>#</a></h2><p>在mininet和真实硬件上测试,所使用的trace从CAIDA\[2\]上获得</p><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><ul><li>DynaPFV Mode
实现MAC及其定时功能</li><li>Kernel Model
修改Floodlight, 使数据平面可以只接收packetOut而不接收修改流表操作</li></ul><h3 id=experiment-setup>Experiment Setup<a hidden class=anchor aria-hidden=true href=#experiment-setup>#</a></h3><ul><li>实验平台</li><li>攻击的实现<ul><li>丢包: 使用ovs-ofctl工具<a href=http://openvswitch.org>在这</a>.</li><li>包注入: 使用<a href=http://tcpreplay.appneta.com/>TCPreply</a>.</li><li>\(\theta\): 设为98.9</li></ul></li></ul><h3 id=mininet-experiment-results>Mininet Experiment Results<a hidden class=anchor aria-hidden=true href=#mininet-experiment-results>#</a></h3><p>每个主机生成250个流并每秒共生成1000个包
<em>Experiment A1: Detection Accuracy</em> 见图6a:不同的触发概率, 不同的攻击, 不同的篡改间隔, 不同的篡改持续时间</p><figure><img loading=lazy src=/ox-hugo/28563pkD.png></figure><p>图6a是检测性能对不同\(\lambda\)的检测效果, 动态的效果更好.</p><p><em>Experiment A.2: Selection of \(\tau\)</em>: 实验结果如下:</p><figure><img loading=lazy src=/ox-hugo/285632uJ.png></figure><p>结果表明可以在6秒内检测出大多数攻击.</p><p><em>Experiment A.3: Detection Delay</em>: 检测不同\(\lambda\)时的检测时延和流数与检测时延的关系, 结果见图8</p><figure><img loading=lazy src=/ox-hugo/28563D5P.png></figure><p><em>Experiment A.4: Overhead</em>: 比较不同\(\lambda\)时packetIn的触发概率,导致的延迟和吞吐量的变化, 比较不同path长度时包的将会延迟, 检测结果如图9. 再没通信代价, 结果见图10</p><figure><img loading=lazy src=/ox-hugo/28563QDW.png></figure><figure><img loading=lazy src=/ox-hugo/28563dNc.png></figure><h3 id=hardware-testbed-experiment-results>Hardware Testbed Experiment Results<a hidden class=anchor aria-hidden=true href=#hardware-testbed-experiment-results>#</a></h3><p>使用4个EdgeCore AS4610-54T交换机, 使用 <a href="http://www.caida.org/data/passive/trace_stats/chicago-B/2015/?monitor=2%200150219-130000.UTC">CAIDE数据集</a>.
<em>Experiment B.1: Detection Delays</em>: 不同的包率和不同攻击的检测延迟,CDF见图11:</p><figure><img loading=lazy src=/ox-hugo/28563qXi.png></figure><p><em>Experiment B.2: Overhead</em>: 对包传输时迟的影响和吞吐量随\(\lambda\)的变化见图12:</p><figure><img loading=lazy src=/ox-hugo/285633ho.png></figure></div><footer class=post-footer><ul class=post-tags><li><a href=https://examplesite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></li></ul><nav class=paginav><a class=prev href=https://examplesite.com/posts/org_10_topo_discover/><span class=title>« Prev</span><br><span>Current Trends of Discovery Topology in SDN</span>
</a><a class=next href=https://examplesite.com/posts/05_ovs_install/><span class=title>Next »</span><br><span>mininet , ovs , ryu 分别进行源码安装</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Dynamic Packet Forwarding Verification in SDN on x" href="https://x.com/intent/tweet/?text=Dynamic%20Packet%20Forwarding%20Verification%20in%20SDN&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f&amp;hashtags=%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dynamic Packet Forwarding Verification in SDN on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f&amp;title=Dynamic%20Packet%20Forwarding%20Verification%20in%20SDN&amp;summary=Dynamic%20Packet%20Forwarding%20Verification%20in%20SDN&amp;source=https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dynamic Packet Forwarding Verification in SDN on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f&title=Dynamic%20Packet%20Forwarding%20Verification%20in%20SDN"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dynamic Packet Forwarding Verification in SDN on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dynamic Packet Forwarding Verification in SDN on whatsapp" href="https://api.whatsapp.com/send?text=Dynamic%20Packet%20Forwarding%20Verification%20in%20SDN%20-%20https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dynamic Packet Forwarding Verification in SDN on telegram" href="https://telegram.me/share/url?text=Dynamic%20Packet%20Forwarding%20Verification%20in%20SDN&amp;url=https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dynamic Packet Forwarding Verification in SDN on ycombinator" href="https://news.ycombinator.com/submitlink?t=Dynamic%20Packet%20Forwarding%20Verification%20in%20SDN&u=https%3a%2f%2fexamplesite.com%2fposts%2forg_09_dyna%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://examplesite.com/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>