<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git的基本使用 | ExampleSite</title><meta name=keywords content="git"><meta name=description content='基础(最常用的命令)
git init #初始化Git仓库
git add . #添加所有未追踪文件或修改
git add filename #添加指定文件
git commit -m "commit information" # 提交
git push #推送到远程
git pull #从远程拉取
git status # 查看当前状态
git log # 查看提交日志
版本回退
前一个版本:
I&rsquo;m a little tired!!!
当前版本:
I&rsquo;m not tired!!!
这时使用 git add 和 git commit 提交了, 但是想回退过去的操作办法如下:


git中HEAD表示当前的提交版本, HEAD^表示前一个提交版本,所以想回退的操作为: git reset --hard HEAD^'><meta name=author content="Me"><link rel=canonical href=https://hubing688.github.io/posts/org_04_git_usage/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hubing688.github.io/posts/org_04_git_usage/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hubing688.github.io/posts/org_04_git_usage/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="Git的基本使用"><meta property="og:description" content='基础(最常用的命令) git init #初始化Git仓库 git add . #添加所有未追踪文件或修改 git add filename #添加指定文件 git commit -m "commit information" # 提交 git push #推送到远程 git pull #从远程拉取 git status # 查看当前状态 git log # 查看提交日志 版本回退 前一个版本:
I’m a little tired!!!
当前版本:
I’m not tired!!!
这时使用 git add 和 git commit 提交了, 但是想回退过去的操作办法如下:
git中HEAD表示当前的提交版本, HEAD^表示前一个提交版本,所以想回退的操作为: git reset --hard HEAD^'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-06T19:28:00+08:00"><meta property="article:modified_time" content="2022-08-17T18:33:07+08:00"><meta property="article:tag" content="Git"><meta property="og:image" content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Git的基本使用"><meta name=twitter:description content='基础(最常用的命令)
git init #初始化Git仓库
git add . #添加所有未追踪文件或修改
git add filename #添加指定文件
git commit -m "commit information" # 提交
git push #推送到远程
git pull #从远程拉取
git status # 查看当前状态
git log # 查看提交日志
版本回退
前一个版本:
I&rsquo;m a little tired!!!
当前版本:
I&rsquo;m not tired!!!
这时使用 git add 和 git commit 提交了, 但是想回退过去的操作办法如下:


git中HEAD表示当前的提交版本, HEAD^表示前一个提交版本,所以想回退的操作为: git reset --hard HEAD^'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hubing688.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Git的基本使用","item":"https://hubing688.github.io/posts/org_04_git_usage/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git的基本使用","name":"Git的基本使用","description":"基础(最常用的命令) git init #初始化Git仓库 git add . #添加所有未追踪文件或修改 git add filename #添加指定文件 git commit -m \u0026#34;commit information\u0026#34; # 提交 git push #推送到远程 git pull #从远程拉取 git status # 查看当前状态 git log # 查看提交日志 版本回退 前一个版本:\nI\u0026rsquo;m a little tired!!!\n当前版本:\nI\u0026rsquo;m not tired!!!\n这时使用 git add 和 git commit 提交了, 但是想回退过去的操作办法如下:\ngit中HEAD表示当前的提交版本, HEAD^表示前一个提交版本,所以想回退的操作为: git reset --hard HEAD^\n","keywords":["git"],"articleBody":"基础(最常用的命令) git init #初始化Git仓库 git add . #添加所有未追踪文件或修改 git add filename #添加指定文件 git commit -m \"commit information\" # 提交 git push #推送到远程 git pull #从远程拉取 git status # 查看当前状态 git log # 查看提交日志 版本回退 前一个版本:\nI’m a little tired!!!\n当前版本:\nI’m not tired!!!\n这时使用 git add 和 git commit 提交了, 但是想回退过去的操作办法如下:\ngit中HEAD表示当前的提交版本, HEAD^表示前一个提交版本,所以想回退的操作为: git reset --hard HEAD^\n未回退命令时日志显示: 有两个版本: first 和 not tired\n使用回退命令后日志显示: 只有 first 了\n当知道commit ID时, 使用 commit ID直接跳到想要的版本.\n比如现在想再返回 not tired, 操作命令为: git reset --hard commit_id\n这时再查看log结果为:\n可以看到, 使用了这个命令后, 我们的not tired 提交又回来了.\n当不知道commit ID时也是有办法的\ngit提供了 git reflog 命令, 这个命令的输出结果是记录你的每一次命令, 使用 git reflog 命令查看历史命令:\n可以看到第一列记录了所有的commit ID, 最后一列记录了执行的操作, 根据最后一列信息找到对应的ID号即可\n回退问题: 如何跳到某个指定commit_id的版本? 假如你刚提交了一个版本, 现在后悔了想返回到前一个版本, 应该使用什么命令? 假如你回退到前某个版本, 现在后悔了, 想返回到最近的某个版本, 但是 commit_id 不记得, 该怎么办? 回退总结: HEAD 为当前版本, 使git reset --hard commit_id 可以跳到对应的版本\ngit reflog 命令可以查看所有操作的记录, 可以用于查找所需要的版本号\ntip: HEAD表示当前版本, HEAD^表示前一个提交版本, HEAD^^为前2个提交的版本, HEAD~100 为第前100个版本\n撤销修改 前一节所说的版本回退有个缺点,\n那就是, 回退到前一个版本, 所有相关文件的最新修改均会丢失.\n并且版本回退是针对已提交的内容的.\n现在有个新问题: 在git管理的版本下, 撤销对某个文件的修改.\n这之前要了解一下git管理的基本逻辑.\ngit 基本逻辑 git仓库其实分为工作区(working tree), 暂存区(stage), 和 仓库()\n工作区就是我们看到和使用的部分\n暂存区是我们使用 git add filename 后文件所到达的部分\n仓库是我们使用 git commit 后文件所在的部分\n在使用 git commit 命令时, 只会将暂存区部分的内容保存到仓库\n文件修改的撤销 在上一次提交后, 本次我们对某个文件进行了修改, 发现修改后程序运行出错了. 现在删除对文件的修改, 应该怎么做(并未使用 git add命令)?\n这时需要的命令为 git checkout -- filename.\n对文件修改后查看工作区状态:\n可以看到有修改, 这时使用 git checkout filename 后结果为:\n再次查看文件, 修改己经没有了\n假设这次我们对文件进行了修改, 且已经使用了 git add filename了该怎么办呢? 办法是使用 git reset HEAD filename 记其回到未 add 的情况.\n我们将修改添加到暂存区, 并查看状态:\n先看一下与前面的区别, 未add时, 字是红色的, 提示信息是\"尚未暂存以备提交的变更\"\n使用 git add filename 后提示信息是\"要提交的变更\"\n此时使用 git reset HEAD filename 后的状态为:\n可以看到取消了暂存的变更, 这时查看状态则又到了修改未提交的状态了.\n此时再使用 git checkout -- filename 命令即可以撤销修改了.\n撤销问题 有修改, 但是未添加到暂存区, 如何撤销? 有修改, 已添加到暂存区, 如何撤销? 撤销总结 git checkout -- filename 撤销对工作区文件的修改 git reset HEAD filename 撤销对文件的暂存操作 文件删除 git仓库的文件删除和正常文件夹的删除不大一样, 因为git将删除也视为了一个操作, 因此删除也需要提交. 正常删除文件后查看仓库状态:\n同样, 使用 git checkout -- filename也可以取消该操作.\n使用 git rm filename 删除文件后查看状态:\n可以看到, 直接删除后提示信息是红色的, 且提示信息是\"修改尚未加入提交\".\n也就是说, 这时还需要使用 git add命令才可以使用 git commit将删除操作提交到仓库.\n而 git rm filename则可以直接将删除提交到仓库.\n对于已添加,未添加的修改如何撤销可见上一节.\n删除问题 若要删除仓库中的文件应如何操作? 直接删除与使用 git rm 命令删除有何不同? 删除后如何撤销? 删除总结 删除与修改一样, 都是要提交到仓库的 使用 git rm 操作相当于使用 直接删除并使用了 git add 命令 删除的撤销可根据是否添加到暂存区同修改一样操作 分支 创建与合并 分支的创建与删除: git branch branch_name\n创建新分支前:\n创建新分支后: git branch newBranch (* 表示当前HEAD所在的分析, 即当前工作区的分支)\n切换分支: git checkout newBranch 可以看到 * 从main到了newBranch\n分支删除: git branch -d newBranch (不能删除当前所在分支, 因此要先切回main分支才可执行该操作)\n分支的合并现有两个分支:main和bugFix 合并前:\n将HEAD放在main分支上, 并执行 git merge bugFix:\n可以看到, 合并会产生一个新的提交, 且当前节点有了两个父节点.\n这里其实可以更深入理解下git checkout这个命令, 它的真实作用是切换当前工作区在git这个仓库树中的位置.即, HEAD可以指向main或者bugFix这种具体的分支名, 也可以指向某一个commit_id(每一个commit_id即是工作区的一个版本)\n冲突的修正 假如我们现在有2个分支: master和newBranch, 在这两个分支中我们都对一个文件进行了修改. 这时, 将newBranch分支合并到master分支时就会出现冲突:\n这里master分支中我们添加的内容是\"Creating a new branch!!!“并提交了.\n在newBranch分支中我们添加的内容是\"Create a new branch!!!”.\n所以在HEAD处于master分支, 并运行 git merge newBranch时会出现冲突.\n我们打开提示的冲突文件, 文件内容如下:\nGit用\u003c，=，\u003e标记出不同分支的内容，我们修改如下后保存：\n这时查看仓库状态为:\n此时将其添加到仓库并提交\n这时查看日志树可以看到合并过程:\n分支问题 如何创建分支与删除分支? 如何在不同分支中进行切换? 如何合并不同的分支? 合并分支后有冲突了该怎么办? 分支总结 分支创建: git branch branch_name 分支删除: git branch -d branch_name 将其他分支合并到当前分支: git merge other_branch 分支切换: git checkout branch_name 冲突解决: 修正冲突的文件并添加到暂存区, 然后提交 高级篇:命令详解 分离HEAD 这是一个很小的概念, 单独说它, 就是因为它很重要.\n其实git是由不同的提交组成, 每个提交都可以看成一个树中的节点.\n所有的提交在一起组成了一个提交树.\n而当前的工作区(也就是我们能看到并修改的那些文件), 就是HEAD所指向的.\n其实HEAD并不是非要指向具体的分支, 它也可以直接指向某个提交.\n比如当前的提交树为:\n可以看到*在bugFix这个分支上, 这也表示HEAD指向bugFix, 我们可以直接让它指向C4 git checkout C4 (这里的C4是提交id):\n同样, 也可以使用这个命令让它指向 main, 或者 C0:\n其实checkout这个命令用来切换HEAD的指向并不准确, 新版的git使用switch命令\n相对引用(^) 在不同的仓库进行切换时, 使用commit id十分麻烦, 因为id需要使用git log命令查找, git提供了相对引用, 即^表示上一个, ^^表示上2个, ~10 表示前10个.\n如使用 git checkout main^ 效果为:\n可以看到当HAED指向main时, HEAD^和main^都是指向C5的.\n再次使用 git checkout HEAD~3 结果为:\n撤销变更 (reset \u0026 revert) 当本地出错要回退时, 有2个命令可用.\nreset可将当前分支回退到指定提交. 可看执行结果: 原本提交树是这样, 使用 git reset HEAD^ 后:\n可以看到, 这个命令让分支放弃了当前节点而指向了父节点.\n若对原本的提交树使用 git revert HEAD^ 命令后的提交树为:\n可以看到, 现在这人分支指向了C1’这个提交, 其实C1’与C1是相同的, 但是 git 将回退作为一个操作然后提交到仓库.\n这样做的好处: 在本地其实是没有什么区别的, 但是如果推送到远程, 使用git reset后若要与远程同步, 需要将远程的最新提交删除, 这个操作难以实现, 因此将回退作为一个新的提交可以方便远程与本地的同步, 方便多人合作.\n提交树的节点移动 (rebase \u0026 cherry-pick) rebase: 它的主要作用是创建线性提交记录, 方便工程修改脉路整理. 比如对于当前提交树:\n我们使用 git rebase main后提交树变化为:\n现在分析一下这个结果. feature 和 main 分支的公共父节点是C1, 我在的HEAD指向feature, 此时运行以上命令后, git 将C2,C4 提交接到了main所指向的C3上, 也就是说: 这个命令会将当前分支的所有提交接到指定的分支上\n因此 rebase 可以表象地理解为 剪枝 + 嫁接\n如果使用merge命令的话提交树会变为:\n这时提交记录则不够线性, 不方便查看对工程的修改历史\nrebase 的另一个功能: 提交记录排序与删除.\ngit rebase -i HEAD~4: 这个命令会弹出一个交互式的创口, 让你调整最新4个提交节点的顺序或者删除提交节点. 下面是一个例子:\n知道这个功能即可, 不具体说明了\ncherry-pick: 这个命令允许我们随意地移动提交树中的节点, 将指定的提交节点移动到当前的HEAD所指定的节点下.\n对以下提交树:\n使用 git cherry-pick C2 C4 C6 后结果为:\n可以看到, 选中的提交节点都添加到了当前分支 main 所指向的节点下.\n这样的命令有什么作用呢?\n场景一: 当前出了一些问题, 可此需要新建一些分支来解决, 最终解决了当前的问题: 但是此时, 我们只想要收录解决问题的提交到当前的main下, 此时就可以使用 rebase -i 和 cherry-pick 这两个命令来实现.\n将HEAD调整到main分支上, 再使用 git cherry-pick C4 (左) 或者使用 git rebase -i HEAD~3 后调整提交 (右) 即可获得:\n场景二: 更新历史提交节点中的信息 下面的提交树中, 我想更新newImage提交中的信息, 且是只更新它的信息, 可使用 rebase -i 和 cherry-pick 这两种方式来实现.\n口述使用 rebase -i 命令过程: 先调整C2和C3顺序,将C2提交节点放到最前, 再使用 git commit --amend 来提交列新C2中的信息, 最后使用 rebase -i 命令将C3节点放到最前.\n详细说明 cherry-pick 过程 (因为不用交互, 易于博客中展示). 首先调整HEAD到main: git checkout main\n其次, 将C2 拿到最前: git cherry-pick C2\n然后, 修改C2中的内容并提交: git commit --amend\n最后, 将C3节点放到最前: git cherry-pick C3\ntag 前文中提交节点要么是使用提交ID标识的, 要么是使用分支名子标识的.\n分支名字会被移动, 且有新的提交时分支名字也会移动到新的提交节点中, 提交ID太长,难记.因此需要一个为某个提交节点进行永久命各的办法: 它就是tag. 对于以下的提交树:\n为不同的提交节点添加tag, 如运行命令: git tag V1 C1, git tag V2 C2, 这时的提交树为:\n同时, 可以直接利用tag名称来移动HEAD: git checkout V1\n可以看到这时HEAD指向了C1. 为什么不是V1* 呢, 这是因为无支对某个tag直接提交, 所以才会发生这种分离HEAD的现象.\ndescribe git describe : 为提交树中的引用, 默认为HEAD.\n该命令的输出结果为: __g, tag为与该引用最近的标签, num 为 该引用与最近标签的间隔提交数, 为的提交ID.\n对于以下的提交树, 使用 git describe, git describe main, git describe side 的结果分别为:\n","wordCount":"661","inLanguage":"en","image":"https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-08-06T19:28:00+08:00","dateModified":"2022-08-17T18:33:07+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hubing688.github.io/posts/org_04_git_usage/"},"publisher":{"@type":"Organization","name":"ExampleSite","logo":{"@type":"ImageObject","url":"https://hubing688.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hubing688.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://hubing688.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hubing688.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://hubing688.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://hubing688.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hubing688.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hubing688.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Git的基本使用</h1><div class=post-meta><span title='2022-08-06 19:28:00 +0800 +0800'>August 6, 2022</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>661 words</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/org_04_git_usage.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=post-content><h2 id=基础--最常用的命令>基础(最常用的命令)<a hidden class=anchor aria-hidden=true href=#基础--最常用的命令>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git init <span class=c1>#初始化Git仓库</span>
</span></span><span class=line><span class=cl>git add . <span class=c1>#添加所有未追踪文件或修改</span>
</span></span><span class=line><span class=cl>git add filename <span class=c1>#添加指定文件</span>
</span></span><span class=line><span class=cl>git commit -m <span class=s2>&#34;commit information&#34;</span> <span class=c1># 提交</span>
</span></span><span class=line><span class=cl>git push <span class=c1>#推送到远程</span>
</span></span><span class=line><span class=cl>git pull <span class=c1>#从远程拉取</span>
</span></span><span class=line><span class=cl>git status <span class=c1># 查看当前状态</span>
</span></span><span class=line><span class=cl>git log <span class=c1># 查看提交日志</span>
</span></span></code></pre></div><h2 id=版本回退>版本回退<a hidden class=anchor aria-hidden=true href=#版本回退>#</a></h2><p>前一个版本:</p><p>I&rsquo;m a little tired!!!</p><p>当前版本:</p><p>I&rsquo;m not tired!!!</p><p>这时使用 <code>git add</code> 和 <code>git commit</code> 提交了, 但是想回退过去的操作办法如下:</p><ol><li><p>git中HEAD表示当前的提交版本, HEAD^表示前一个提交版本,所以想回退的操作为: <code>git reset --hard HEAD^</code></p><p>未回退命令时日志显示: 有两个版本: first 和 not tired</p><figure><img loading=lazy src=/ox-hugo/w9ia1T.png></figure><p>使用回退命令后日志显示: 只有 first 了</p><figure><img loading=lazy src=/ox-hugo/z40Rxp.png></figure></li><li><p>当知道commit ID时, 使用 commit ID直接跳到想要的版本.</p><p>比如现在想再返回 not tired, 操作命令为: <code>git reset --hard commit_id</code></p><p>这时再查看log结果为:</p><figure><img loading=lazy src=/ox-hugo/xbNFyu.png></figure><p>可以看到, 使用了这个命令后, 我们的not tired 提交又回来了.</p></li><li><p>当不知道commit ID时也是有办法的</p><p>git提供了 <code>git reflog</code> 命令, 这个命令的输出结果是记录你的每一次命令, 使用 <code>git reflog</code> 命令查看历史命令:</p><figure><img loading=lazy src=/ox-hugo/yoXAyX.png></figure><p>可以看到第一列记录了所有的commit ID, 最后一列记录了执行的操作, 根据最后一列信息找到对应的ID号即可</p></li></ol><h3 id=回退问题>回退问题:<a hidden class=anchor aria-hidden=true href=#回退问题>#</a></h3><ul><li>如何跳到某个指定commit_id的版本?</li><li>假如你刚提交了一个版本, 现在后悔了想返回到前一个版本, 应该使用什么命令?</li><li>假如你回退到前某个版本, 现在后悔了, 想返回到最近的某个版本, 但是 commit_id 不记得, 该怎么办?</li></ul><h3 id=回退总结>回退总结:<a hidden class=anchor aria-hidden=true href=#回退总结>#</a></h3><ul><li><p>HEAD 为当前版本, 使<code>git reset --hard commit_id</code>
可以跳到对应的版本</p></li><li><p><code>git reflog</code> 命令可以查看所有操作的记录, 可以用于查找所需要的版本号</p></li><li><p>tip: HEAD表示当前版本, HEAD^表示前一个提交版本, HEAD^^为前2个提交的版本, HEAD~100 为第前100个版本</p></li></ul><h2 id=撤销修改>撤销修改<a hidden class=anchor aria-hidden=true href=#撤销修改>#</a></h2><p>前一节所说的版本回退有个缺点,</p><p>那就是, 回退到前一个版本, 所有相关文件的最新修改均会丢失.</p><p>并且版本回退是针对已提交的内容的.</p><p>现在有个新问题: 在git管理的版本下, 撤销对某个文件的修改.</p><p>这之前要了解一下git管理的基本逻辑.</p><h3 id=git-基本逻辑>git 基本逻辑<a hidden class=anchor aria-hidden=true href=#git-基本逻辑>#</a></h3><p>git仓库其实分为工作区(working tree), 暂存区(stage), 和 仓库()</p><p>工作区就是我们看到和使用的部分</p><p>暂存区是我们使用 <code>git add filename</code> 后文件所到达的部分</p><p>仓库是我们使用 <code>git commit</code> 后文件所在的部分</p><p>在使用 <code>git commit</code> 命令时, 只会将暂存区部分的内容保存到仓库</p><h3 id=文件修改的撤销>文件修改的撤销<a hidden class=anchor aria-hidden=true href=#文件修改的撤销>#</a></h3><ol><li>在上一次提交后, 本次我们对某个文件进行了修改, 发现修改后程序运行出错了.</li></ol><p>现在删除对文件的修改, 应该怎么做(并未使用 <code>git add</code>命令)?</p><p>这时需要的命令为 <code>git checkout -- filename</code>.</p><p>对文件修改后查看工作区状态:</p><figure><img loading=lazy src=/ox-hugo/wgzKkV.png></figure><p>可以看到有修改, 这时使用 <code>git checkout filename</code> 后结果为:</p><figure><img loading=lazy src=/ox-hugo/WFnHaa.png></figure><p>再次查看文件, 修改己经没有了</p><ol><li>假设这次我们对文件进行了修改, 且已经使用了 <code>git add filename</code>了该怎么办呢?</li></ol><p>办法是使用 <code>git reset HEAD filename</code> 记其回到未 add 的情况.</p><p>我们将修改添加到暂存区, 并查看状态:</p><figure><img loading=lazy src=/ox-hugo/mEZNH4.png></figure><p>先看一下与前面的区别, 未add时, 字是红色的, 提示信息是"尚未暂存以备提交的变更"</p><p>使用 <code>git add filename</code> 后提示信息是"要提交的变更"</p><p>此时使用 <code>git reset HEAD filename</code> 后的状态为:</p><figure><img loading=lazy src=/ox-hugo/KCUntl.png></figure><p>可以看到取消了暂存的变更, 这时查看状态则又到了修改未提交的状态了.</p><p>此时再使用 <code>git checkout -- filename</code> 命令即可以撤销修改了.</p><h3 id=撤销问题>撤销问题<a hidden class=anchor aria-hidden=true href=#撤销问题>#</a></h3><ul><li>有修改, 但是未添加到暂存区, 如何撤销?</li><li>有修改, 已添加到暂存区, 如何撤销?</li></ul><h3 id=撤销总结>撤销总结<a hidden class=anchor aria-hidden=true href=#撤销总结>#</a></h3><ul><li><code>git checkout -- filename</code> 撤销对工作区文件的修改</li><li><code>git reset HEAD filename</code> 撤销对文件的暂存操作</li></ul><h2 id=文件删除>文件删除<a hidden class=anchor aria-hidden=true href=#文件删除>#</a></h2><p>git仓库的文件删除和正常文件夹的删除不大一样, 因为git将删除也视为了一个操作, 因此删除也需要提交.
正常删除文件后查看仓库状态:</p><figure><img loading=lazy src=/ox-hugo/mbERgz.png></figure><p>同样, 使用 <code>git checkout -- filename</code>也可以取消该操作.</p><figure><img loading=lazy src=/ox-hugo/zl1Gmn.png></figure><p>使用 <code>git rm filename</code> 删除文件后查看状态:</p><figure><img loading=lazy src=/ox-hugo/HTRJOe.png></figure><p>可以看到, 直接删除后提示信息是红色的, 且提示信息是"修改尚未加入提交".</p><p>也就是说, 这时还需要使用 <code>git add</code>命令才可以使用 <code>git commit</code>将删除操作提交到仓库.</p><p>而 <code>git rm filename</code>则可以直接将删除提交到仓库.</p><p>对于已添加,未添加的修改如何撤销可见上一节.</p><h3 id=删除问题>删除问题<a hidden class=anchor aria-hidden=true href=#删除问题>#</a></h3><ol><li>若要删除仓库中的文件应如何操作?</li><li>直接删除与使用 git rm 命令删除有何不同?</li><li>删除后如何撤销?</li></ol><h3 id=删除总结>删除总结<a hidden class=anchor aria-hidden=true href=#删除总结>#</a></h3><ol><li>删除与修改一样, 都是要提交到仓库的</li><li>使用 git rm 操作相当于使用 直接删除并使用了 git add 命令</li><li>删除的撤销可根据是否添加到暂存区同修改一样操作</li></ol><h2 id=分支>分支<a hidden class=anchor aria-hidden=true href=#分支>#</a></h2><h3 id=创建与合并>创建与合并<a hidden class=anchor aria-hidden=true href=#创建与合并>#</a></h3><ol><li><p>分支的创建与删除: <code>git branch branch_name</code></p><p>创建新分支前:</p><figure><img loading=lazy src=/ox-hugo/RlYsKB.png></figure><p>创建新分支后: <code>git branch newBranch</code> (* 表示当前HEAD所在的分析, 即当前工作区的分支)</p><figure><img loading=lazy src=/ox-hugo/k7pjsa.png></figure><p>切换分支: <code>git checkout newBranch</code> 可以看到 * 从main到了newBranch</p><figure><img loading=lazy src=/ox-hugo/HRQps3.png></figure><p>分支删除: <code>git branch -d newBranch</code>
(不能删除当前所在分支, 因此要先切回main分支才可执行该操作)</p><figure><img loading=lazy src=/ox-hugo/DtLHUp.png></figure></li><li><p>分支的合并现有两个分支:main和bugFix 合并前:</p><figure><img loading=lazy src=/ox-hugo/Xgr0JH.png></figure><p>将HEAD放在main分支上, 并执行 <code>git merge bugFix</code>:</p><figure><img loading=lazy src=/ox-hugo/NbBBBn.png></figure><p>可以看到, 合并会产生一个新的提交, 且当前节点有了两个父节点.</p><p><strong>这里其实可以更深入理解下git checkout这个命令, 它的真实作用是切换当前工作区在git这个仓库树中的位置.即, HEAD可以指向main或者bugFix这种具体的分支名, 也可以指向某一个commit_id(每一个commit_id即是工作区的一个版本)</strong></p></li></ol><h3 id=冲突的修正>冲突的修正<a hidden class=anchor aria-hidden=true href=#冲突的修正>#</a></h3><p>假如我们现在有2个分支: master和newBranch, 在这两个分支中我们都对一个文件进行了修改.
这时, 将newBranch分支合并到master分支时就会出现冲突:</p><figure><img loading=lazy src=/ox-hugo/Irdghd.png></figure><p>这里master分支中我们添加的内容是"Creating a new branch!!!&ldquo;并提交了.</p><p>在newBranch分支中我们添加的内容是"Create a new branch!!!&rdquo;.</p><p>所以在HEAD处于master分支, 并运行 <code>git merge newBranch</code>时会出现冲突.</p><p>我们打开提示的冲突文件, 文件内容如下:</p><figure><img loading=lazy src=/ox-hugo/wTslN6.png></figure><p>Git用&lt;，=，>标记出不同分支的内容，我们修改如下后保存：</p><figure><img loading=lazy src=/ox-hugo/kxnfVi.png></figure><p>这时查看仓库状态为:</p><figure><img loading=lazy src=/ox-hugo/cFEfh0.png></figure><p>此时将其添加到仓库并提交</p><figure><img loading=lazy src=/ox-hugo/WtsCWB.png></figure><p>这时查看日志树可以看到合并过程:</p><figure><img loading=lazy src=/ox-hugo/53BVr8.png></figure><h3 id=分支问题>分支问题<a hidden class=anchor aria-hidden=true href=#分支问题>#</a></h3><ol><li>如何创建分支与删除分支?</li><li>如何在不同分支中进行切换?</li><li>如何合并不同的分支?</li><li>合并分支后有冲突了该怎么办?</li></ol><h3 id=分支总结>分支总结<a hidden class=anchor aria-hidden=true href=#分支总结>#</a></h3><ol><li>分支创建: <code>git branch branch_name</code></li><li>分支删除: <code>git branch -d branch_name</code></li><li>将其他分支合并到当前分支: <code>git merge other_branch</code></li><li>分支切换: <code>git checkout branch_name</code></li><li>冲突解决: 修正冲突的文件并添加到暂存区, 然后提交</li></ol><h2 id=高级篇-命令详解>高级篇:命令详解<a hidden class=anchor aria-hidden=true href=#高级篇-命令详解>#</a></h2><h3 id=分离head>分离HEAD<a hidden class=anchor aria-hidden=true href=#分离head>#</a></h3><p>这是一个很小的概念, 单独说它, 就是因为它很重要.</p><p>其实git是由不同的提交组成, 每个提交都可以看成一个树中的节点.</p><p>所有的提交在一起组成了一个提交树.</p><p>而当前的工作区(也就是我们能看到并修改的那些文件), 就是HEAD所指向的.</p><p>其实HEAD并不是非要指向具体的分支, 它也可以直接指向某个提交.</p><p>比如当前的提交树为:</p><figure><img loading=lazy src=/ox-hugo/M9hgtM.png></figure><p>可以看到*在bugFix这个分支上, 这也表示HEAD指向bugFix, 我们可以直接让它指向C4 <code>git checkout C4</code> (这里的C4是提交id):</p><figure><img loading=lazy src=/ox-hugo/Wx4zBM.png></figure><p>同样, 也可以使用这个命令让它指向 main, 或者 C0:</p><figure><img loading=lazy src=/ox-hugo/fI2krA.png></figure><figure><img loading=lazy src=/ox-hugo/czULVl.png></figure><p><strong>其实checkout这个命令用来切换HEAD的指向并不准确, 新版的git使用switch命令</strong></p><h3 id=相对引用>相对引用(^)<a hidden class=anchor aria-hidden=true href=#相对引用>#</a></h3><ol><li><p>在不同的仓库进行切换时, 使用commit id十分麻烦, 因为id需要使用git log命令查找, git提供了相对引用, 即^表示上一个, ^^表示上2个, ~10 表示前10个.</p><p>如使用 <code>git checkout main^</code> 效果为:</p><p><img loading=lazy src=/ox-hugo/k7l8fp.png><img loading=lazy src=/ox-hugo/Vopopj.png></p><p>可以看到当HAED指向main时, HEAD^和main^都是指向C5的.</p><p>再次使用 <code>git checkout HEAD~3</code> 结果为:</p><figure><img loading=lazy src=/ox-hugo/fbSQSq.png></figure></li></ol><h3 id=撤销变更--reset-and-revert>撤销变更 (reset & revert)<a hidden class=anchor aria-hidden=true href=#撤销变更--reset-and-revert>#</a></h3><p>当本地出错要回退时, 有2个命令可用.</p><ol><li>reset可将当前分支回退到指定提交. 可看执行结果:</li></ol><figure><img loading=lazy src=/ox-hugo/dIjvRu.png></figure><p>原本提交树是这样, 使用 <code>git reset HEAD^</code> 后:</p><figure><img loading=lazy src=/ox-hugo/DA3wQF.png></figure><p>可以看到, 这个命令让分支放弃了当前节点而指向了父节点.</p><p>若对原本的提交树使用 <code>git revert HEAD^</code> 命令后的提交树为:</p><figure><img loading=lazy src=/ox-hugo/RgrX6M.png></figure><p>可以看到, 现在这人分支指向了C1&rsquo;这个提交, 其实C1&rsquo;与C1是相同的, 但是 git 将回退作为一个操作然后提交到仓库.</p><p>这样做的好处: 在本地其实是没有什么区别的, 但是如果推送到远程, 使用git reset后若要与远程同步, 需要将远程的最新提交删除, 这个操作难以实现, 因此将回退作为一个新的提交可以方便远程与本地的同步, 方便多人合作.</p><h3 id=提交树的节点移动--rebase-and-cherry-pick>提交树的节点移动 (rebase & cherry-pick)<a hidden class=anchor aria-hidden=true href=#提交树的节点移动--rebase-and-cherry-pick>#</a></h3><ul><li><p>rebase: 它的主要作用是创建线性提交记录, 方便工程修改脉路整理. 比如对于当前提交树:</p><figure><img loading=lazy src=/ox-hugo/PNMENq.png></figure><p>我们使用 <code>git rebase main</code>后提交树变化为:</p><figure><img loading=lazy src=/ox-hugo/nwkPME.png></figure><p>现在分析一下这个结果. feature 和 main 分支的公共父节点是C1, 我在的HEAD指向feature, 此时运行以上命令后, git 将C2,C4 提交接到了main所指向的C3上, 也就是说: <strong>这个命令会将当前分支的所有提交接到指定的分支上</strong></p><p>因此 rebase 可以表象地理解为 剪枝 + 嫁接</p><p>如果使用merge命令的话提交树会变为:</p></li></ul><figure><img loading=lazy src=/ox-hugo/RSAjyP.png></figure><p>这时提交记录则不够线性, 不方便查看对工程的修改历史</p><ul><li><p>rebase 的另一个功能: 提交记录排序与删除.</p><p><code>git rebase -i HEAD~4</code>: 这个命令会弹出一个交互式的创口, 让你调整最新4个提交节点的顺序或者删除提交节点. 下面是一个例子:</p><p><img loading=lazy src=/ox-hugo/Xy3uNG.png> <img loading=lazy src=/ox-hugo/HwlFsT.png></p><p>知道这个功能即可, 不具体说明了</p></li><li><p>cherry-pick: 这个命令允许我们随意地移动提交树中的节点, 将指定的提交节点移动到当前的HEAD所指定的节点下.</p><p>对以下提交树:</p><figure><img loading=lazy src=/ox-hugo/ZwNIwd.png></figure><p>使用 <code>git cherry-pick C2 C4 C6</code> 后结果为:</p><figure><img loading=lazy src=/ox-hugo/th4ZK3.png></figure></li></ul><p>可以看到, 选中的提交节点都添加到了当前分支 main 所指向的节点下.</p><p>这样的命令有什么作用呢?</p><h4 id=场景一-当前出了一些问题-可此需要新建一些分支来解决-最终解决了当前的问题>场景一: 当前出了一些问题, 可此需要新建一些分支来解决, 最终解决了当前的问题:<a hidden class=anchor aria-hidden=true href=#场景一-当前出了一些问题-可此需要新建一些分支来解决-最终解决了当前的问题>#</a></h4><figure><img loading=lazy src=/ox-hugo/fnM15C.png></figure><p>但是此时, 我们只想要收录解决问题的提交到当前的main下, 此时就可以使用 rebase -i 和 cherry-pick 这两个命令来实现.</p><p>将HEAD调整到main分支上, 再使用 <code>git cherry-pick C4</code> (左) 或者使用 <code>git rebase -i HEAD~3</code> 后调整提交 (右) 即可获得:</p><p><img loading=lazy src=/ox-hugo/ZJ9rxO.png> <img loading=lazy src=/ox-hugo/n0IeTw.png></p><h4 id=场景二-更新历史提交节点中的信息>场景二: 更新历史提交节点中的信息<a hidden class=anchor aria-hidden=true href=#场景二-更新历史提交节点中的信息>#</a></h4><p>下面的提交树中, 我想更新newImage提交中的信息, 且是只更新它的信息, 可使用 rebase -i 和 cherry-pick 这两种方式来实现.</p><figure><img loading=lazy src=/ox-hugo/6Qk8bS.png></figure><p>口述使用 rebase -i 命令过程: 先调整C2和C3顺序,将C2提交节点放到最前, 再使用 <code>git commit --amend</code> 来提交列新C2中的信息, 最后使用 rebase -i 命令将C3节点放到最前.</p><p>详细说明 cherry-pick 过程 (因为不用交互, 易于博客中展示). 首先调整HEAD到main: <code>git checkout main</code></p><figure><img loading=lazy src=/ox-hugo/jpy5A2.png></figure><p>其次, 将C2 拿到最前: <code>git cherry-pick C2</code></p><figure><img loading=lazy src=/ox-hugo/odNTKf.png></figure><p>然后, 修改C2中的内容并提交: <code>git commit --amend</code></p><figure><img loading=lazy src=/ox-hugo/0tYSy8.png></figure><p>最后, 将C3节点放到最前: <code>git cherry-pick C3</code></p><figure><img loading=lazy src=/ox-hugo/jFWrjx.png></figure><h3 id=tag>tag<a hidden class=anchor aria-hidden=true href=#tag>#</a></h3><p>前文中提交节点要么是使用提交ID标识的, 要么是使用分支名子标识的.</p><p>分支名字会被移动, 且有新的提交时分支名字也会移动到新的提交节点中, 提交ID太长,难记.因此需要一个为某个提交节点进行永久命各的办法: 它就是tag. 对于以下的提交树:</p><figure><img loading=lazy src=/ox-hugo/CVhCSx.png></figure><p>为不同的提交节点添加tag, 如运行命令: <code>git tag V1 C1, git tag V2 C2</code>, 这时的提交树为:</p><figure><img loading=lazy src=/ox-hugo/XThrHE.png></figure><p>同时, 可以直接利用tag名称来移动HEAD: <code>git checkout V1</code></p><figure><img loading=lazy src=/ox-hugo/4fBhAY.png></figure><p>可以看到这时HEAD指向了C1. 为什么不是V1* 呢, 这是因为无支对某个tag直接提交, 所以才会发生这种分离HEAD的现象.</p><h3 id=describe>describe<a hidden class=anchor aria-hidden=true href=#describe>#</a></h3><p><code>git describe &lt;ref></code>: &lt;ref> 为提交树中的引用, 默认为HEAD.</p><p>该命令的输出结果为: &lt;tag>_&lt;num>_g&lt;hash>, tag为与该引用最近的标签, num 为 该引用与最近标签的间隔提交数, &lt;hash>为&lt;ref>的提交ID.</p><p>对于以下的提交树, 使用 <code>git describe, git describe main, git describe side</code> 的结果分别为:</p><figure><img loading=lazy src=/ox-hugo/dWzKw3.png></figure><figure><img loading=lazy src=/ox-hugo/ZObRUN.png></figure></div><footer class=post-footer><ul class=post-tags><li><a href=https://hubing688.github.io/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://hubing688.github.io/posts/org_05_magit_usage/><span class=title>« Prev</span><br><span>Magit的基本使用</span>
</a><a class=next href=https://hubing688.github.io/posts/org_03_git_get_started/><span class=title>Next »</span><br><span>Git 与 Magit 初始篇</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Git的基本使用 on x" href="https://x.com/intent/tweet/?text=Git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f&amp;hashtags=git"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git的基本使用 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f&amp;title=Git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8&amp;summary=Git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8&amp;source=https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git的基本使用 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f&title=Git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git的基本使用 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git的基本使用 on whatsapp" href="https://api.whatsapp.com/send?text=Git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8%20-%20https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git的基本使用 on telegram" href="https://telegram.me/share/url?text=Git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8&amp;url=https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Git的基本使用 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Git%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8&u=https%3a%2f%2fhubing688.github.io%2fposts%2forg_04_git_usage%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hubing688.github.io/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>