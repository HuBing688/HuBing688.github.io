<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks | ExampleSite</title><meta name=keywords content="论文阅读"><meta name=description content="
Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer & Communications Security. ACM, 2013.

本文对of作两个改进：1,利用Connection Migration对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,actuating trigger改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。
整体架构见图1

系统设计
Connection Migration
利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤：
1收到SYN,分类：三次握手完成
2报告：得到控制器允许并插入规则
3转移：找目的host，并成功shake
4报告：通知控制器
5中继，源和目的host建立TCP session
可见图2

分类（classification stage）
流程见图3

收到TCP：查flow Table,在？交付
不在？是不是SYN？是：ACK
否：RST或丢弃
收到TCP ACK处理流程

收到TCP ACK，查flow table，在？交付
不在？查SYN缓存，有：report
无：RST或丢弃
Report stage
将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration
否：未说"><meta name=author content="Me"><link rel=canonical href=https://hubing688.github.io/posts/18_avant-guard/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hubing688.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hubing688.github.io/posts/18_avant-guard/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://hubing688.github.io/posts/18_avant-guard/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks"><meta property="og:description" content=" Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer & Communications Security. ACM, 2013.
本文对of作两个改进：1,利用Connection Migration对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,actuating trigger改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。 整体架构见图1
系统设计 Connection Migration 利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤： 1收到SYN,分类：三次握手完成 2报告：得到控制器允许并插入规则 3转移：找目的host，并成功shake 4报告：通知控制器 5中继，源和目的host建立TCP session 可见图2
分类（classification stage） 流程见图3
收到TCP：查flow Table,在？交付 不在？是不是SYN？是：ACK 否：RST或丢弃
收到TCP ACK处理流程
收到TCP ACK，查flow table，在？交付 不在？查SYN缓存，有：report 无：RST或丢弃
Report stage 将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration 否：未说"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-31T18:32:36+08:00"><meta property="article:modified_time" content="2022-08-22T18:32:36+08:00"><meta property="article:tag" content="论文阅读"><meta property="og:image" content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks"><meta name=twitter:description content="
Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer & Communications Security. ACM, 2013.

本文对of作两个改进：1,利用Connection Migration对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,actuating trigger改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。
整体架构见图1

系统设计
Connection Migration
利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤：
1收到SYN,分类：三次握手完成
2报告：得到控制器允许并插入规则
3转移：找目的host，并成功shake
4报告：通知控制器
5中继，源和目的host建立TCP session
可见图2

分类（classification stage）
流程见图3

收到TCP：查flow Table,在？交付
不在？是不是SYN？是：ACK
否：RST或丢弃
收到TCP ACK处理流程

收到TCP ACK，查flow table，在？交付
不在？查SYN缓存，有：report
无：RST或丢弃
Report stage
将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration
否：未说"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hubing688.github.io/posts/"},{"@type":"ListItem","position":2,"name":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","item":"https://hubing688.github.io/posts/18_avant-guard/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","name":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","description":" Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer \u0026amp; Communications Security. ACM, 2013.\n本文对of作两个改进：1,利用Connection Migration对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,actuating trigger改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。 整体架构见图1\n系统设计 Connection Migration 利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤： 1收到SYN,分类：三次握手完成 2报告：得到控制器允许并插入规则 3转移：找目的host，并成功shake 4报告：通知控制器 5中继，源和目的host建立TCP session 可见图2\n分类（classification stage） 流程见图3\n收到TCP：查flow Table,在？交付 不在？是不是SYN？是：ACK 否：RST或丢弃\n收到TCP ACK处理流程\n收到TCP ACK，查flow table，在？交付 不在？查SYN缓存，有：report 无：RST或丢弃\nReport stage 将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration 否：未说\n","keywords":["论文阅读"],"articleBody":" Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer \u0026 Communications Security. ACM, 2013.\n本文对of作两个改进：1,利用Connection Migration对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,actuating trigger改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。 整体架构见图1\n系统设计 Connection Migration 利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤： 1收到SYN,分类：三次握手完成 2报告：得到控制器允许并插入规则 3转移：找目的host，并成功shake 4报告：通知控制器 5中继，源和目的host建立TCP session 可见图2\n分类（classification stage） 流程见图3\n收到TCP：查flow Table,在？交付 不在？是不是SYN？是：ACK 否：RST或丢弃\n收到TCP ACK处理流程\n收到TCP ACK，查flow table，在？交付 不在？查SYN缓存，有：report 无：RST或丢弃\nReport stage 将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration 否：未说\nMigration Stage CM与目的主机shake，将shake结果报告给controller\nRelay Stage 正常中继TCP\n举个例子：如图5\nCM的好处 可降低与TCP握手有关洪泛攻击的影响。 可收集到所有尝试连接数和连接成功数，并以此分析是否有洪泛攻击或探针攻击进行。 延迟CM 当收到一个TCP连接请求时，收到第一个数据包时才开始report，避免真实TCP连接的攻击。\nActuating Triggers 它的作用是异步报告信息给Controller，帮助Controller快速管理。它由四步组成：\n定义触发条件 condition 注册到date plane date plane 检测包是否满足当前条件 满足：告诉Controller;插入指定规则 Defining a Condition: 本文支三个条件：payload-based,traffic-rate-based,rule-activation 条件格式为：${type:\\qquad condition:\\qquad pointer}$，并对条件的bit位数，以及每一位表示何种意义进行了解释。\n数据平面发现条件满足，并有pointer，就添加pointer所指向的rule到flowtable中，图7是一个事件触发场景图解。即当数据平面发现流满足某个条件时就触发条件流表中规定好的行为 。\nCondition Registration 条件流表下发到date plane即可\nTraffic Rate Monitoring 监测流率，将触发条件并入date plane的计数管理逻辑中。 ###Event Notification 当date plane监测到符合条件的信号时就通知Controller。 ###例 payload-based条件中，当条件满足时将标志位置1,就可将相应包传到Controller,图8中，Controller想要10.0.0.1的所有包，告诉date plane匹配条件，若相匹配就将其交给Controller即可。\n对于condition Flow Rule Activation，当某些条满足时自动在date plane激活rule，可用来自动处理DDoS这类攻击而不用通知Controller,这样的条件规则需要在date plane实现两个组件：存放规则的内存，用于发现规则的指针。图10说明如何插入并激活一个流规则。\n1-3下发安装规则，检测包，4满足条件通知，5插入流规则。\n系统实现 见图11\na是正常的数据平面实现结构，b是实现了我们协议的数据平面，在b中，header parser被修改以抽取TCP flags，arbiter被修改以强制packet editor来进行连接转移并应答TCP SYN/ACK，并为packet editor添加连接处理模块。 添加两个数据结构以支持中继，ACK/SEQ。可选添加Option以处理TCP Option。 实现Actuating Triggers时，利用已有的TCAM和SRAM. 图c是利用switch的CUP和DRAM简化实现。 在A-G中，Controller和switch中都要添加表1中的命令。\n评估 AG用例 两个场景：AG,传统OF应用预防 三个攻击：网络饱和攻击，网络扫描攻击，网络入侵攻击。 Controller使用POX，switch运行在i5CPU和8G memory。\n网络饱和攻击 拓扑如图12\n测试情景分别在有，无A-G，有，无DDoS四种情况下进行，请求网络所需要平均时间如表2\n攻击强度为0-800个包，10个良性客户端请求率如图13\n结果一顿夸\n络扫描攻击 该攻击传统OF也可容易检测出来，但使用AG更加简单，只需要定期收个TCP会话信息即可。图16,17表示使用和不使用AG的区别，16中未使用，attacker最终找到了那个打开的端口，17中使用了AG，他扫到所有的端口都是开着的。\n网络入侵检测 使用的攻击是RPC buffer overflow 比较：OF只会发送无法匹配的包头到Controller，因此无法检测到该类攻击，AG可以定义指定特征包并将其发送到Controller Application进行分析.\nOverhead Measurement CM 分析使用AG和OF中建立一个新连接的时间，理论分析见图像20,21\n理论一顿解释\n后通过实验说明AG花费时间开销特别小。\nActuating Triggers 检测检查条件时所消费的时间，表3给出平均时间\n所花时间极少。\n本文不足：无法预防应用层攻击，UDP,ICMP攻击。\n","wordCount":"167","inLanguage":"en","image":"https://hubing688.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2019-08-31T18:32:36+08:00","dateModified":"2022-08-22T18:32:36+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hubing688.github.io/posts/18_avant-guard/"},"publisher":{"@type":"Organization","name":"ExampleSite","logo":{"@type":"ImageObject","url":"https://hubing688.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://hubing688.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://hubing688.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hubing688.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://hubing688.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://hubing688.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://hubing688.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://hubing688.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks</h1><div class=post-meta><span title='2019-08-31 18:32:36 +0800 +0800'>August 31, 2019</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>167 words</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/18_AVANT-GUARD.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=post-content><blockquote><p>Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer & Communications Security. ACM, 2013.</p></blockquote><p>本文对of作两个改进：1,利用<em>Connection Migration</em>对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,<em>actuating trigger</em>改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。
整体架构见图1</p><p><img alt=AgIoex.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgIoex.png></p><h1 id=系统设计>系统设计<a hidden class=anchor aria-hidden=true href=#系统设计>#</a></h1><h2 id=connection-migration>Connection Migration<a hidden class=anchor aria-hidden=true href=#connection-migration>#</a></h2><p>利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤：
1收到SYN,分类：三次握手完成
2报告：得到控制器允许并插入规则
3转移：找目的host，并成功shake
4报告：通知控制器
5中继，源和目的host建立TCP session
可见图2</p><p><a href=https://imgchr.com/i/AgI5O1><img alt=AgI5O1.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgI5O1.png></a></p><h3 id=分类classification-stage>分类（classification stage）<a hidden class=anchor aria-hidden=true href=#分类classification-stage>#</a></h3><p>流程见图3</p><p><img alt=AgIv6A.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgIv6A.png></p><p>收到TCP：查flow Table,在？交付
不在？是不是SYN？是：ACK
否：RST或丢弃</p><p>收到TCP ACK处理流程</p><p><img alt=AgoSmt.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgoSmt.png></p><p>收到TCP ACK，查flow table，在？交付
不在？查SYN缓存，有：report
无：RST或丢弃</p><h3 id=report-stage>Report stage<a hidden class=anchor aria-hidden=true href=#report-stage>#</a></h3><p>将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration
否：未说</p><h3 id=migration-stage>Migration Stage<a hidden class=anchor aria-hidden=true href=#migration-stage>#</a></h3><p>CM与目的主机shake，将shake结果报告给controller</p><h3 id=relay-stage>Relay Stage<a hidden class=anchor aria-hidden=true href=#relay-stage>#</a></h3><p>正常中继TCP</p><p>举个例子：如图5</p><p><img alt=AgT6GF.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgT6GF.png></p><h3 id=cm的好处>CM的好处<a hidden class=anchor aria-hidden=true href=#cm的好处>#</a></h3><ul><li>可降低与TCP握手有关洪泛攻击的影响。</li><li>可收集到所有尝试连接数和连接成功数，并以此分析是否有洪泛攻击或探针攻击进行。</li></ul><h3 id=延迟cm>延迟CM<a hidden class=anchor aria-hidden=true href=#延迟cm>#</a></h3><p>当收到一个TCP连接请求时，收到第一个数据包时才开始report，避免真实TCP连接的攻击。</p><h2 id=actuating-triggers>Actuating Triggers<a hidden class=anchor aria-hidden=true href=#actuating-triggers>#</a></h2><p>它的作用是异步报告信息给Controller，帮助Controller快速管理。它由四步组成：</p><ul><li>定义触发条件 condition</li><li>注册到date plane</li><li>date plane 检测包是否满足当前条件</li><li>满足：告诉Controller;插入指定规则</li></ul><h3 id=defining-a-condition>Defining a Condition:<a hidden class=anchor aria-hidden=true href=#defining-a-condition>#</a></h3><p>本文支三个条件：payload-based,traffic-rate-based,rule-activation
条件格式为：${type:\qquad condition:\qquad pointer}$，并对条件的bit位数，以及每一位表示何种意义进行了解释。</p><p><a href=https://imgchr.com/i/AgHr3F><img alt=AgHr3F.md.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgHr3F.md.png></a></p><p>数据平面发现条件满足，并有pointer，就添加pointer所指向的rule到flowtable中，图7是一个事件触发场景图解。即当数据平面发现流满足某个条件时就触发条件流表中规定好的行为 。</p><p><img alt=AgHgBR.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgHgBR.png></p><h3 id=condition-registration>Condition Registration<a hidden class=anchor aria-hidden=true href=#condition-registration>#</a></h3><p>条件流表下发到date plane即可</p><h3 id=traffic-rate-monitoring>Traffic Rate Monitoring<a hidden class=anchor aria-hidden=true href=#traffic-rate-monitoring>#</a></h3><p>监测流率，将触发条件并入date plane的计数管理逻辑中。
###Event Notification
当date plane监测到符合条件的信号时就通知Controller。
###例
payload-based条件中，当条件满足时将标志位置1,就可将相应包传到Controller,图8中，Controller想要10.0.0.1的所有包，告诉date plane匹配条件，若相匹配就将其交给Controller即可。</p><p><img alt=AgbOsJ.png loading=lazy src=https://s2.ax1x.com/2019/04/04/AgbOsJ.png></p><p>对于condition Flow Rule Activation，当某些条满足时自动在date plane激活rule，可用来自动处理DDoS这类攻击而不用通知Controller,这样的条件规则需要在date plane实现两个组件：存放规则的内存，用于发现规则的指针。图10说明如何插入并激活一个流规则。</p><p><img alt=A2Zubn.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2Zubn.png></p><p>1-3下发安装规则，检测包，4满足条件通知，5插入流规则。</p><h1 id=系统实现>系统实现<a hidden class=anchor aria-hidden=true href=#系统实现>#</a></h1><p>见图11</p><p><a href=https://imgchr.com/i/A2ZoRS><img alt=A2ZoRS.md.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2ZoRS.md.png></a></p><p>a是正常的数据平面实现结构，b是实现了我们协议的数据平面，在b中，header parser被修改以抽取TCP flags，arbiter被修改以强制packet editor来进行连接转移并应答TCP SYN/ACK，并为packet editor添加连接处理模块。
添加两个数据结构以支持中继，ACK/SEQ。可选添加Option以处理TCP Option。
实现Actuating Triggers时，利用已有的TCAM和SRAM.
图c是利用switch的CUP和DRAM简化实现。
在A-G中，Controller和switch中都要添加表1中的命令。</p><p><a href=https://imgchr.com/i/A2ns2T><img alt=A2ns2T.md.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2ns2T.md.png></a></p><h1 id=评估>评估<a hidden class=anchor aria-hidden=true href=#评估>#</a></h1><h2 id=ag用例>AG用例<a hidden class=anchor aria-hidden=true href=#ag用例>#</a></h2><p>两个场景：AG,传统OF应用预防
三个攻击：网络饱和攻击，网络扫描攻击，网络入侵攻击。
Controller使用POX，switch运行在i5CPU和8G memory。</p><h3 id=网络饱和攻击>网络饱和攻击<a hidden class=anchor aria-hidden=true href=#网络饱和攻击>#</a></h3><p>拓扑如图12</p><p><img alt=A2Q8oj.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2Q8oj.png></p><p>测试情景分别在有，无A-G，有，无DDoS四种情况下进行，请求网络所需要平均时间如表2</p><p><img alt=A2Qcf1.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2Qcf1.png></p><p>攻击强度为0-800个包，10个良性客户端请求率如图13</p><p><img alt=A2QRl6.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2QRl6.png></p><p>结果一顿夸</p><h3 id=络扫描攻击>络扫描攻击<a hidden class=anchor aria-hidden=true href=#络扫描攻击>#</a></h3><p>该攻击传统OF也可容易检测出来，但使用AG更加简单，只需要定期收个TCP会话信息即可。图16,17表示使用和不使用AG的区别，16中未使用，attacker最终找到了那个打开的端口，17中使用了AG，他扫到所有的端口都是开着的。</p><p><img alt=A2lVnU.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2lVnU.png></p><p><img alt=A2lnAJ.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2lnAJ.png></p><h3 id=网络入侵检测>网络入侵检测<a hidden class=anchor aria-hidden=true href=#网络入侵检测>#</a></h3><p><img alt=A2luN9.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2luN9.png></p><p>使用的攻击是RPC buffer overflow
比较：OF只会发送无法匹配的包头到Controller，因此无法检测到该类攻击，AG可以定义指定特征包并将其发送到Controller Application进行分析.</p><h2 id=overhead-measurement>Overhead Measurement<a hidden class=anchor aria-hidden=true href=#overhead-measurement>#</a></h2><h3 id=cm>CM<a hidden class=anchor aria-hidden=true href=#cm>#</a></h3><p>分析使用AG和OF中建立一个新连接的时间，理论分析见图像20,21</p><p><a href=https://imgchr.com/i/A2la4A><img alt=A2la4A.md.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2la4A.md.png></a></p><p>理论一顿解释</p><p><img alt=A2l03t.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A2l03t.png></p><p>后通过实验说明AG花费时间开销特别小。</p><h2 id=actuating-triggers-1>Actuating Triggers<a hidden class=anchor aria-hidden=true href=#actuating-triggers-1>#</a></h2><p>检测检查条件时所消费的时间，表3给出平均时间</p><p><img alt=A28l3n.png loading=lazy src=https://s2.ax1x.com/2019/04/04/A28l3n.png></p><p>所花时间极少。</p><p>本文不足：无法预防应用层攻击，UDP,ICMP攻击。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://hubing688.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/>论文阅读</a></li></ul><nav class=paginav><a class=prev href=https://hubing688.github.io/posts/19_sphinx/><span class=title>« Prev</span><br><span>SPHINX: Detecting Security Attacks in Software-Defined Networks</span>
</a><a class=next href=https://hubing688.github.io/posts/17_sdn-rdcd_ton/><span class=title>Next »</span><br><span>SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks on x" href="https://x.com/intent/tweet/?text=AVANT-GUARD%3a%20scalable%20and%20vigilant%20switch%20flow%20management%20in%20software-defined%20networks&amp;url=https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f&amp;hashtags=%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f&amp;title=AVANT-GUARD%3a%20scalable%20and%20vigilant%20switch%20flow%20management%20in%20software-defined%20networks&amp;summary=AVANT-GUARD%3a%20scalable%20and%20vigilant%20switch%20flow%20management%20in%20software-defined%20networks&amp;source=https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f&title=AVANT-GUARD%3a%20scalable%20and%20vigilant%20switch%20flow%20management%20in%20software-defined%20networks"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks on whatsapp" href="https://api.whatsapp.com/send?text=AVANT-GUARD%3a%20scalable%20and%20vigilant%20switch%20flow%20management%20in%20software-defined%20networks%20-%20https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks on telegram" href="https://telegram.me/share/url?text=AVANT-GUARD%3a%20scalable%20and%20vigilant%20switch%20flow%20management%20in%20software-defined%20networks&amp;url=https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks on ycombinator" href="https://news.ycombinator.com/submitlink?t=AVANT-GUARD%3a%20scalable%20and%20vigilant%20switch%20flow%20management%20in%20software-defined%20networks&u=https%3a%2f%2fhubing688.github.io%2fposts%2f18_avant-guard%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hubing688.github.io/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>